<?xml version="1.0" encoding="UTF-8"?>
<!--
This Work is in the public domain and is provided on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
including, without limitation, any warranties or conditions of TITLE,
NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.
You are solely responsible for determining the appropriateness of using
this Work and assume any risks associated with your use of this Work.

This Work includes contributions authored by David E. Jones, not as a
"work for hire", who hereby disclaims any copyright to the same.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-1.5.xsd">

    <!-- STATUS: EXPERIMENTAL -->

    <service verb="get" noun="AssetDisplayInfo">
        <in-parameters><parameter name="assetId"/></in-parameters>
        <out-parameters>
            <parameter name="asset" type="EntityValue"/>
            <parameter name="statusItem" type="EntityValue"/>
            <parameter name="product" type="EntityValue"/>
            <parameter name="facility" type="EntityValue"/>
            <parameter name="facilityLocation" type="EntityValue"/>
            <parameter name="originFacility" type="EntityValue"/>
            <parameter name="assetDetailList" type="EntityList"/>
            <parameter name="assetReservationList" type="EntityList"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset"/>
            <set field="statusItem" from="asset.'Asset#moqui.basic.StatusItem'"/>
            <set field="facility" from="asset.'mantle.facility.Facility'"/>
            <set field="facilityLocation" from="asset.'mantle.facility.FacilityLocation'"/>
            <set field="product" from="asset.'mantle.product.Product'"/>
            <set field="originFacility" from="asset.'Origin#mantle.facility.Facility'"/>
            <entity-find entity-name="mantle.product.asset.AssetDetail" list="assetDetailList">
                <econdition field-name="assetId"/><order-by field-name="effectiveDate"/></entity-find>
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="assetReservationList">
                <econdition field-name="assetId"/><order-by field-name="reservedDate"/></entity-find>
        </actions>
    </service>

    <service verb="update" noun="AssetFromDetail">
        <description>Called by EECA rule to update Asset quantities when an AssetDetail record is created.</description>
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="availableToPromiseDiff" type="BigDecimal"/>
            <parameter name="quantityOnHandDiff" type="BigDecimal"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <!-- view-entity with sum function approach, doesn't work with TransactionCache:
            <entity-find-one entity-name="AssetDetailSummary" value-field="assetDetailSummary"/>
            <set field="asset.availableToPromiseTotal" from="assetDetailSummary.availableToPromiseTotal ?: 0"/>
            <set field="asset.quantityOnHandTotal" from="assetDetailSummary.quantityOnHandTotal ?: 0"/>
            -->
            <set field="asset.availableToPromiseTotal" from="(asset.availableToPromiseTotal ?: 0) + (availableToPromiseDiff ?: 0)"/>
            <set field="asset.quantityOnHandTotal" from="(asset.quantityOnHandTotal ?: 0) + (quantityOnHandDiff ?: 0)"/>
            <entity-update value-field="asset"/>
        </actions>
    </service>

    <service verb="reserve" noun="AssetsForOrder">
        <!-- this is triggered by an SECA rule on OrderHeader status change to OrderPlaced (see ProductAsset.secas.xml) -->
        <in-parameters><parameter name="orderId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <set field="productStore" from="orderHeader.'mantle.product.store.ProductStore'"/>
            <!-- if store setup for no reservation return now -->
            <if condition="productStore?.reservationOrderEnumId == 'AsResOrdNoRes'"><return/></if>
            
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId"/>
                <order-by field-name="orderItemSeqId"/>
            </entity-find>
            <iterate list="orderItemList" entry="orderItem">
                <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                        in-map="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId, productStore:productStore]"/>
            </iterate>
        </actions>
    </service>
    <service verb="reserve" noun="AssetForOrderItem">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
            <parameter name="productStore" type="EntityValue"><description>Optional, gets from OrderHeader if not passed.
                If there is no OrderHeader.productStoreId defaults to reservationOrderEnumId=AsResOrdFifoRec and gets
                inventoryFacilityId from OrderPart.facilityId and organizationPartyId from OrderPart.vendorPartyId.</description></parameter>
            <parameter name="assetId"><description>Optional assetId, reserves against this first if specified.</description></parameter>
            <parameter name="assetIdList" type="List"><description>Optional List of assetId values, reserves against these first (in order) if specified.</description></parameter>
            <parameter name="resetReservations" type="Boolean" default="false"><description>If true remove existing reservations before reserving.</description></parameter>
        </in-parameters>
        <actions>
            <!-- do a FOR UPDATE query on OrderItem as a semaphore -->
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem" for-update="true"/>

            <!-- first check the OrderItem, make sure we have a productId otherwise don't reserve -->
            <set field="productId" from="orderItem.productId"/>
            <if condition="!productId"><return/></if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <entity-find-related-one value-field="orderItem" relationship-name="mantle.order.OrderPart" to-value-field="orderPart"/>

            <!-- check OrderHeader and OrderPart status, return immediately if not OrderPlaced, OrderProcessing, OrderApproved, OrderSent, or OrderHold -->
            <set field="resStatusList" from="['OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderHold']"/>
            <if condition="!(orderHeader.statusId in resStatusList) || !(orderPart.statusId in resStatusList)"><return/></if>

            <!-- before finding remaining quantity and getting existing reservations, resetReservations if specified -->
            <if condition="resetReservations">
                <service-call name="mantle.product.AssetServices.remove#OrderItemReservations" in-map="context"/>
            </if>

            <set field="quantityRemaining" from="orderItem.quantity"/>

            <!-- if there are any existing reservations, deduct their quantity -->
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList">
                <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/>
                <order-by field-name="-reservedDate"/><!-- get most recent first for reducing reservation quantities -->
            </entity-find>
            <iterate list="existingResList" entry="existingRes">
                <set field="quantityRemaining" from="quantityRemaining - existingRes.quantity"/>
            </iterate>
            <!-- if nothing to reserve or un-reserve return now -->
            <if condition="quantityRemaining == 0"><return/></if>

            <!-- handle too much reserved -->
            <if condition="quantityRemaining &lt; 0">
                <set field="quantityToDeduct" from="-quantityRemaining"/>
                <iterate list="existingResList" entry="existingRes">
                    <if condition="quantityToDeduct >= existingRes.quantity &amp;&amp; existingRes.quantity == existingRes.quantityNotIssued">
                        <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:existingRes.assetId,
                                effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:existingRes.quantity,
                                assetReservationId:existingRes.assetReservationId, productId:existingRes.productId]"/>

                        <set field="quantityToDeduct" from="quantityToDeduct - existingRes.quantity"/>
                        <entity-delete value-field="existingRes"/>

                        <else>
                            <set field="curQuantityToDeduct" from="existingRes.quantityNotIssued &gt; quantityToDeduct ?
                                    quantityToDeduct : existingRes.quantityNotIssued"/>
                            <!-- add to ATP on Asset through a detail record -->
                            <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:existingRes.assetId,
                                effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:curQuantityToDeduct,
                                assetReservationId:existingRes.assetReservationId, productId:existingRes.productId,
                                orderId:existingRes.orderId, orderItemSeqId:existingRes.orderItemSeqId]"/>
                            <!-- reduce quantities on AssetReservation -->
                            <set field="existingRes.quantity" from="existingRes.quantity - curQuantityToDeduct"/>
                            <set field="existingRes.quantityNotAvailable"
                                    from="existingRes.quantityNotAvailable &gt; curQuantityToDeduct ?
                                        existingRes.quantityNotAvailable - curQuantityToDeduct : 0"/>
                            <set field="existingRes.quantityNotIssued" from="existingRes.quantityNotIssued - curQuantityToDeduct"/>
                            <entity-update value-field="existingRes"/>

                            <set field="quantityToDeduct" from="quantityToDeduct - curQuantityToDeduct"/>
                        </else>
                    </if>
                    <if condition="quantityToDeduct == 0"><break/></if>
                </iterate>

                <if condition="quantityToDeduct != 0">
                    <return error="true" message="Unable to remove reservations for ${quantityToDeduct} out of ${-quantityRemaining} attempted, not enough quantity reserved and not issued"/>
                    <else><return/></else>
                </if>
            </if>

            <!-- no store passed? find it from OrderHeader -->
            <if condition="productStore == null">
                <entity-find-related-one value-field="orderHeader" relationship-name="mantle.product.store.ProductStore"
                        to-value-field="productStore" cache="true"/>
            </if>
            <!-- if store setup for no reservation return now -->
            <if condition="productStore?.reservationOrderEnumId == 'AsResOrdNoRes'"><return/></if>
            <!-- otherwise set assetOrderBy field based on reservationOrderEnumId -->
            <set field="reservationOrderEnumId" from="productStore?.reservationOrderEnumId ?: 'AsResOrdFifoRec'"/>
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="resOrderEnum">
                <field-map field-name="enumId" from="reservationOrderEnumId"/></entity-find-one>
            <set field="assetOrderBy" from="resOrderEnum?.enumCode ?: 'receivedDate'"/><!-- default: FIFO by received date -->

            <set field="inventoryFacilityId" from="productStore?.inventoryFacilityId ?: orderPart?.facilityId"/>
            <set field="organizationPartyId" from="productStore?.organizationPartyId ?: orderPart?.vendorPartyId"/>

            <!-- if organizationPartyId is not an internal org this is not a sales order, so don't do inventory res (return) -->
            <entity-find-one entity-name="mantle.party.PartyRole" value-field="orgPartyRole">
                <field-map field-name="partyId" from="organizationPartyId"/>
                <field-map field-name="roleTypeId" value="OrgInternal"/>
            </entity-find-one>
            <if condition="productStore == null &amp;&amp; orgPartyRole == null"><return/></if>

            <!-- do the reservation... -->
            <set field="baseMap" from="[orderId:orderId, orderItemSeqId:orderItemSeqId, productId:productId]"/>

            <set field="explicitAssetIdList" from="[]"/>
            <if condition="assetId"><script>explicitAssetIdList.add(assetId)</script></if>
            <if condition="assetIdList"><script>explicitAssetIdList.addAll(assetIdList)</script></if>

            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/><econdition field-name="statusId" value="AstAvailable"/>
                <!-- exclude old, unused Asset records; is not-equals instead of greater so that negative ATP records
                    for not-available reservations will be included and reused -->
                <econdition field-name="availableToPromiseTotal" operator="not-equals" from="0"/>
                <econdition field-name="facilityId" from="inventoryFacilityId" ignore-if-empty="true"/>
                <econdition field-name="ownerPartyId" from="organizationPartyId" ignore-if-empty="true"/>
                <econdition field-name="assetId" operator="not-in" from="explicitAssetIdList" ignore-if-empty="true"/>
                <order-by field-name="${assetOrderBy}"/>
            </entity-find>
            <!-- if explicitAssetIdList specified add to beginning of the list -->
            <if condition="explicitAssetIdList">
                <entity-find entity-name="mantle.product.asset.Asset" list="explicitAssetList">
                    <econdition field-name="assetId" operator="in" from="explicitAssetIdList"/>
                </entity-find>
                <!-- add in order of the original list, won't come from DB in this order (reverse the order since we add to the beginning of the list) -->
                <script>Collections.reverse(explicitAssetIdList)</script>
                <iterate list="explicitAssetIdList" entry="explicitAssetId">
                    <set field="passedAsset" from="null"/>
                    <iterate list="explicitAssetList" entry="explicitAsset">
                        <if condition="explicitAsset.assetId == explicitAssetId">
                            <set field="passedAsset" from="explicitAsset"/>
                            <break/>
                        </if>
                    </iterate>
                    <!-- unless an invalid assetId is passed in passedAsset shouldn't be null, but just in case: -->
                    <script>if (passedAsset) assetList.add(0, passedAsset)</script>
                </iterate>
            </if>

            <if condition="assetList">
                <!-- reserve by availableToPromiseTotal (no reservation here, but respect others) -->
                <iterate list="assetList" entry="asset">
                    <set field="lastAsset" from="asset"/>
                    <if condition="quantityRemaining &gt; 0 &amp;&amp; asset_hasNext">
                        <set field="quantityToReserve" from="asset.availableToPromiseTotal &gt; quantityRemaining ? quantityRemaining : asset.availableToPromiseTotal"/>
                        <set field="quantityRemaining" from="quantityRemaining - quantityToReserve"/>
                        <service-call name="create#mantle.product.issuance.AssetReservation" out-map="resOut" in-map="baseMap +
                                [assetId:asset.assetId, reservedDate:ec.user.nowTimestamp, quantity:quantityToReserve,
                                quantityNotAvailable:0, quantityNotIssued:quantityToReserve, priority:orderItem.priority,
                                sequenceNum:asset_index, reservationOrderEnumId:reservationOrderEnumId]"/>
                        <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap +
                                [assetId:asset.assetId, effectiveDate:ec.user.nowTimestamp,
                                availableToPromiseDiff:-quantityToReserve, assetReservationId:resOut.assetReservationId]"/>
                    </if>
                </iterate>
                <!-- not all issued? issue to last (most recent) Asset -->
                <if condition="quantityRemaining &gt; 0">
                    <set field="quantityNotAvailable" from="lastAsset.availableToPromiseTotal &gt; quantityRemaining ? 0 :
                            (lastAsset.availableToPromiseTotal &gt; 0 ? quantityRemaining - lastAsset.availableToPromiseTotal : quantityRemaining)"/>
                    <service-call name="create#mantle.product.issuance.AssetReservation" out-map="resOut" in-map="baseMap +
                            [assetId:lastAsset.assetId, reservedDate:ec.user.nowTimestamp, quantity:quantityRemaining,
                            quantityNotAvailable:quantityNotAvailable, quantityNotIssued:quantityRemaining,
                            priority:orderItem.priority, sequenceNum:asset_index,
                            reservationOrderEnumId:reservationOrderEnumId]"/>
                    <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap +
                            [assetId:lastAsset.assetId, effectiveDate:ec.user.nowTimestamp,
                            availableToPromiseDiff:-quantityRemaining, assetReservationId:resOut.assetReservationId]"/>
                </if>

                <else>
                    <!-- no asset... create a shell one to record the issuance and detail against -->
                    <service-call name="create#mantle.product.asset.Asset" out-map="assetOut"
                            in-map="[assetTypeEnumId:'AstTpInventory', hasQuantity:'Y', statusId:'AstAvailable',
                                productId:productId, facilityId:inventoryFacilityId,
                                ownerPartyId:organizationPartyId, receivedDate:ec.user.nowTimestamp,
                                availableToPromiseTotal:0, quantityOnHandTotal: 0]"/>
                    <service-call name="create#mantle.product.issuance.AssetReservation" out-map="resOut" in-map="baseMap +
                            [assetId:assetOut.assetId, reservedDate:ec.user.nowTimestamp, quantity:quantityRemaining,
                            quantityNotAvailable:quantityRemaining, quantityNotIssued:quantityRemaining,
                            priority:orderItem.priority, sequenceNum:0,
                            reservationOrderEnumId:reservationOrderEnumId]"/>
                    <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap +
                            [assetId:assetOut.assetId, effectiveDate:ec.user.nowTimestamp,
                            availableToPromiseDiff:-quantityRemaining, assetReservationId:resOut.assetReservationId]"/>
                </else>
            </if>
        </actions>
    </service>

    <service verb="remove" noun="OrderItemReservations">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
        </in-parameters>
        <actions>
            <!-- do a FOR UPDATE query on OrderItem as a semaphore -->
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem" for-update="true"/>

            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList" for-update="true">
                <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/></entity-find>
            <iterate list="existingResList" entry="existingRes">
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:existingRes.assetId,
                        effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:existingRes.quantity,
                        assetReservationId:existingRes.assetReservationId, productId:existingRes.productId]"/>
                <entity-delete value-field="existingRes"/>
            </iterate>
        </actions>
    </service>

    <service verb="reReserve" noun="ProductAssets">
        <in-parameters><parameter name="productId" required="true"/></in-parameters>
        <actions>
            <!-- TODO: implement this (and populate priority on order/item and on reservation) -->
        </actions>
    </service>

    <service verb="reserve" noun="IncreasedAsset">
        <in-parameters><parameter name="assetId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <if condition="asset.availableToPromiseTotal &lt;= 0"><return/></if>
            <if condition="!asset.productId"><return/></if>

            <set field="availableRemaining" from="asset.availableToPromiseTotal"/>
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="resList">
                <econdition field-name="productId" from="asset.productId"/>
                <econdition field-name="quantityNotAvailable" operator="greater" from="0"/>
                <order-by field-name="priority"/><order-by field-name="reservedDate"/>
            </entity-find>
            <iterate list="resList" entry="res">
                <set field="quantityToMove" from="availableRemaining &lt; res.quantityNotAvailable ?
                        availableRemaining : res.quantityNotAvailable"/>
                <!-- quantityNotAvailable > 0 from query so if 0 means nothing left -->
                <if condition="quantityToMove == 0"><break/></if>

                <service-call name="mantle.product.AssetServices.move#AssetReservation"
                        in-map="[assetId:assetId, assetReservationId:res.assetReservationId, quantity:quantityToMove]"/>

                <set field="availableRemaining" from="availableRemaining - quantityToMove"/>
            </iterate>
        </actions>
    </service>
    <service verb="move" noun="AssetReservation">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="assetReservationId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <entity-find-one entity-name="mantle.product.issuance.AssetReservation" value-field="assetReservation" for-update="true"/>
            <set field="quantityToMove" from="asset.availableToPromiseTotal &lt; quantity ? asset.availableToPromiseTotal : quantity"/>

            <if condition="quantityToMove == assetReservation.quantity">
                <!-- move over the whole reservation -->

                <!-- increment old Asset ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetReservation.assetId,
                        effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:quantityToMove,
                        assetReservationId:assetReservationId, productId:assetReservation.productId,
                        orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>
                <!-- decrement new Asset ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetId,
                        effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:-quantityToMove,
                        assetReservationId:assetReservationId, productId:assetReservation.productId,
                        orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>

                <!-- set the new assetId and decrease quantityNotAvailable (should be to 0!) -->
                <set field="assetReservation.assetId" from="assetId"/>
                <set field="assetReservation.quantityNotAvailable"
                        from="assetReservation.quantityNotAvailable &gt; quantityToMove ?
                                        assetReservation.quantityNotAvailable - quantityToMove : 0"/>
                <entity-update value-field="assetReservation"/>

                <else>
                    <!-- create a new reservation, split the quantity -->
                    <service-call name="create#mantle.product.issuance.AssetReservation" out-map="newResOut"
                            in-map="new HashMap(assetReservation) + [assetReservationId:null, assetId:assetId,
                                quantity:quantityToMove, quantityNotAvailable:0, quantityNotIssued:quantityToMove]"/>
                    <!-- decrement old reservation quantities -->
                    <set field="assetReservation.quantity" from="assetReservation.quantity - quantityToMove"/>
                    <set field="assetReservation.quantityNotAvailable"
                            from="assetReservation.quantityNotAvailable &gt; quantityToMove ?
                                        assetReservation.quantityNotAvailable - quantityToMove : 0"/>
                    <set field="assetReservation.quantityNotIssued" from="assetReservation.quantityNotIssued - quantityToMove"/>
                    <entity-update value-field="assetReservation"/>

                    <!-- increment old Asset ATP -->
                    <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetReservation.assetId,
                        effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:quantityToMove,
                        assetReservationId:assetReservationId, productId:assetReservation.productId,
                        orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>
                    <!-- decrement new Asset ATP -->
                    <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetId,
                        effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:-quantityToMove,
                        assetReservationId:newResOut.assetReservationId, productId:assetReservation.productId,
                        orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>
                </else>
            </if>
        </actions>
    </service>

    <service verb="change" noun="AssetQuantity">
        <in-parameters>
            <auto-parameters entity-name="mantle.product.asset.AssetDetail" include="nonpk"/>
            <parameter name="assetId" required="true"/>
            <parameter name="quantityDiff" type="BigDecimal" required="true"/>
            <parameter name="effectiveDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <!-- TODO (future): also use on physical inventory decrease -->

            <service-call name="create#mantle.product.asset.AssetDetail" in-map="context +
                    [quantityOnHandDiff:quantityDiff, availableToPromiseDiff:quantityDiff]"/>

            <if condition="quantityDiff &gt; 0">
                <!-- reserve the newly available Asset, if needed -->
                <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/>
            </if>
            <if condition="quantityDiff &lt; 0">
                <!-- on decrease adjust reservations down (increase quantityNotAvailable); -->
                <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset"/>
                <if condition="asset.availableToPromiseTotal &lt; 0">
                    <set field="negativeAvailable" from="-asset.availableToPromiseTotal"/>
                    <set field="reduceQuantityRemaining" from="-quantityDiff"/>
                    <if condition="reduceQuantityRemaining &gt; negativeAvailable"><set field="reduceQuantityRemaining" from="negativeAvailable"/></if>

                    <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList">
                        <econdition field-name="assetId"/>
                        <order-by field-name="-reservedDate"/><!-- get most recent first for reducing reservation quantities -->
                    </entity-find>
                    <iterate list="existingResList" entry="res">
                        <set field="quantityAvailable" from="res.quantity - res.quantityNotAvailable"/>
                        <set field="quantityToReduce" from="quantityAvailable &gt; reduceQuantityRemaining ? reduceQuantityRemaining : quantityAvailable"/>

                        <set field="res.quantityNotAvailable" from="res.quantityNotAvailable + quantityToReduce"/>
                        <entity-update value-field="res"/>

                        <set field="reduceQuantityRemaining" from="reduceQuantityRemaining - quantityToReduce"/>
                        <if condition="reduceQuantityRemaining == 0"><break/></if>
                    </iterate>
                </if>
            </if>
        </actions>
    </service>

    <service verb="issue" noun="AssetReservation">
        <description>Issue an Asset based on a reservation (AssetReservation).</description>
        <in-parameters>
            <parameter name="assetReservation" type="EntityValue" required="true"/>
            <parameter name="shipmentId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="context"
                    in-map="[assetId:assetReservation.assetId, assetReservationId:assetReservation.assetReservationId,
                        orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId,
                        shipmentId:shipmentId, productId:assetReservation.productId,
                        issuedDate:ec.user.nowTimestamp, quantity:quantity]"/>

            <!-- create AssetDetail to decrement quantityOnHand -->
            <!-- NOTE: no availableToPromiseDiff because that was modified during the reservation -->
            <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetReservation.assetId,
                    effectiveDate:ec.user.nowTimestamp, quantityOnHandDiff:-quantity,
                    assetReservationId:assetReservation.assetReservationId, shipmentId:shipmentId,
                    productId:assetReservation.productId, assetIssuanceId:assetIssuanceId]"/>

            <set field="assetReservation.quantityNotIssued" from="assetReservation.quantityNotIssued - quantity"/>
            <if condition="assetReservation.quantityNotIssued == 0">
                <entity-delete value-field="assetReservation"/>
                <else><entity-update value-field="assetReservation"/></else>
            </if>
        </actions>
    </service>
    <service verb="issue" noun="Asset">
        <description>Issue an Asset with no reservation.</description>
        <in-parameters>
            <parameter name="assetId"><description>Optional assetId, issues against this first if specified.</description></parameter>
            <parameter name="shipmentId" required="true"/>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem"/>
            <set field="productStore" from="orderHeader.'mantle.product.store.ProductStore'"/>
            <!-- <set field="inventoryFacility" from="productStore.'Inventory#mantle.facility.Facility'"/> -->
            <set field="productId" from="orderItem.productId"/>
            <set field="baseMap" from="[orderId:orderId, orderItemSeqId:orderItemSeqId, shipmentId:shipmentId, productId:productId]"/>

            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/>
                <econdition field-name="facilityId" from="productStore.inventoryFacilityId" ignore-if-empty="true"/>
                <econdition field-name="ownerPartyId" from="productStore.organizationPartyId" ignore-if-empty="true"/>
                <!-- reserve from oldest first (ascending receivedDate) -->
                <!-- TODO: this may be configurable in the future -->
                <order-by field-name="receivedDate"/>
            </entity-find>
            <!-- if assetId specified add it to the list -->
            <if condition="assetId">
                <entity-find-one entity-name="mantle.product.asset.Asset" value-field="passedAsset"/>
                <script>assetList.add(0, passedAsset)</script>
            </if>

            <if condition="assetList">
                <!-- reserve by availableToPromiseTotal (no reservation here, but respect others) -->
                <set field="quantityRemaining" from="quantity"/>
                <iterate list="assetList" entry="asset">
                    <set field="lastAsset" from="asset"/>
                    <if condition="quantityRemaining &gt; 0">
                        <set field="quantityToIssue" from="asset.availableToPromiseTotal &gt; quantityRemaining ? quantityRemaining : asset.availableToPromiseTotal"/>
                        <set field="quantityRemaining" from="quantityRemaining - quantityToIssue"/>
                        <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut" in-map="baseMap +
                                [assetId:asset.assetId, issuedDateTime:ec.user.nowTimestamp, quantity:quantityToIssue]"/>
                        <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap + [assetId:asset.assetId,
                                quantityDiff:-quantityToIssue, assetIssuanceId:issueOut.assetIssuanceId]"/>
                    </if>
                </iterate>
                <!-- not all issued? issue to last (most recent) Asset -->
                <if condition="quantityRemaining &gt; 0">
                    <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut" in-map="baseMap +
                            [assetId:lastAsset.assetId, issuedDateTime:ec.user.nowTimestamp, quantity:quantityRemaining]"/>
                    <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap + [assetId:lastAsset.assetId,
                            quantityDiff:-quantityRemaining, assetIssuanceId:issueOut.assetIssuanceId]"/>
                </if>

                <else>
                    <!-- no asset... create a shell one to record the issuance and detail against -->
                    <service-call name="create#mantle.product.asset.Asset" out-map="context"
                            in-map="[assetTypeEnumId:'AstTpInventory', hasQuantity:'Y', statusId:'AstAvailable',
                                productId:productId, facilityId:productStore.inventoryFacilityId,
                                ownerPartyId:productStore.organizationPartyId, receivedDate:ec.user.nowTimestamp,
                                availableToPromiseTotal:0, quantityOnHandTotal: 0]"/>
                    <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut"
                            in-map="baseMap + [assetId:assetId, issuedDateTime:ec.user.nowTimestamp, quantity:quantity]"/>
                    <!-- create AssetDetail to decrement quantityOnHand -->
                    <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap + [assetId:assetId,
                            effectiveDate:ec.user.nowTimestamp, quantityOnHandDiff:-quantity,
                            availableToPromiseDiff:-quantity, assetIssuanceId:issueOut.assetIssuanceId]"/>
                </else>
            </if>
        </actions>
    </service>

    <service verb="issue" noun="AssetToWorkEffort">
        <description>Issue an Asset to a WorkEffort (production run, etc).</description>
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="workEffortId" required="true"/>
            <parameter name="quantity" type="BigDecimal"><description>If not specified entire quantity of given Asset record will be used.</description></parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset"/>
            <if condition="!asset"><return error="true" message="Asset not found with ID ${assetId}"/></if>

            <!-- reserve by availableToPromiseTotal (no reservation here, but respect others) -->
            <if condition="quantity &gt; asset.availableToPromiseTotal">
                <return error="true" message="Quantity specified (${quantity}) is greater than the quantity available (${asset.availableToPromiseTotal})"/>
            </if>

            <set field="baseMap" from="[workEffortId:workEffortId, productId:asset.productId]"/>
            <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut" in-map="baseMap +
                    [assetId:asset.assetId, issuedDateTime:ec.user.nowTimestamp, quantity:quantity]"/>
            <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap + [assetId:asset.assetId,
                    quantityDiff:-quantity, assetIssuanceId:issueOut.assetIssuanceId]"/>
        </actions>
    </service>

    <service verb="receive" noun="Asset">
        <description>Receive an Asset</description>
        <in-parameters>
            <parameter name="assetId"><description>If specified receives to that Asset (uncommon) otherwise creates a new one.</description></parameter>
            <parameter name="productId" required="true" default="defaultProductId"/>
            <parameter name="defaultProductId"><description>Field for special forms, if passed can be used as a default for the productId parameter.</description></parameter>
            <parameter name="quantity" type="BigDecimal" default-value="1"/>
            <parameter name="assetTypeEnumId" default-value="AstTpInventory"/>
            <parameter name="classEnumId"/>
            <parameter name="statusId"><description>If assetTypeEnumId == AstTpInventory then defaults to AstAvailable,
                otherwise defaults to AstInStorage.</description></parameter>

            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk"/>
            <parameter name="assetName"><description>Defaults to OrderItem.itemDescription if available.</description></parameter>
            <parameter name="facilityId" required="true"/>
            <parameter name="ownerPartyId"><description>If not passed in and orderId and orderItemSeqId are then uses
                OrderPart.customerPartyId, otherwise uses Facility.ownerPartyId.</description></parameter>

            <parameter name="shipmentId"/>
            <parameter name="shipmentPackageSeqId"/>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="returnId"/>
            <parameter name="returnItemSeqId"/>
            <parameter name="workEffortId"/>

            <parameter name="quantityRejected" type="BigDecimal"/>
            <parameter name="rejectionReasonEnumId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="assetId"/>
            <parameter name="assetReceiptId"/>
            <parameter name="assetDetailId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem"/>
            <entity-find-one entity-name="mantle.facility.Facility" value-field="facility"/>
            <if condition="!ownerPartyId &amp;&amp; orderItem">
                <set field="orderPart" from="orderItem?.'mantle.order.OrderPart'"/>
                <set field="ownerPartyId" from="orderPart?.customerPartyId"/>
            </if>
            <if condition="!ownerPartyId"><set field="ownerPartyId" from="facility?.ownerPartyId"/></if>

            <if condition="!statusId"><set field="statusId" from="assetTypeEnumId == 'AstTpInventory' ? 'AstAvailable' : 'AstInStorage'"/></if>
            <set field="hasQuantity" from="!serialNumber &amp;&amp; quantity > 1 ? 'Y' : 'N'"/>
            <set field="assetName" from="assetName ?: orderItem?.itemDescription"/>

            <set field="receivedDate" from="ec.user.nowTimestamp"/>

            <if condition="!assetId">
                <!-- TODO: if this has a workEffortId and not an orderId get acquireCost from WorkEffort somehow? -->
                <service-call name="create#mantle.product.asset.Asset" out-map="context" 
                        in-map="context + [quantityOnHandTotal:0, availableToPromiseTotal:0,
                            acquiredDate:(orderHeader?.placedDate ?: ec.user.nowTimestamp),
                            acquireOrderId:orderId, acquireOrderItemSeqId:orderItemSeqId, acquireCost:orderItem?.unitAmount,
                            acquireCostUomId:orderHeader?.currencyUomId, acquireWorkEffortId:workEffortId]"/>
            </if>

            <!-- create AssetReceipt -->
            <service-call name="create#mantle.product.receipt.AssetReceipt" out-map="context"
                    in-map="[assetId:assetId, productId:productId, orderId:orderId, orderItemSeqId:orderItemSeqId,
                        returnId:returnId, returnItemSeqId:returnItemSeqId, shipmentId:shipmentId,
                        workEffortId:workEffortId,
                        shipmentPackageSeqId:shipmentPackageSeqId, receivedByUserId:ec.user.userId,
                        receivedDate:receivedDate, quantityAccepted:quantity, quantityRejected:quantityRejected,
                        rejectionReasonEnumId:rejectionReasonEnumId]"/>

            <!-- if there are OrderItemBilling records matching orderId, orderItemSeqId, and shipmentId set assetReceiptId -->
            <if condition="orderId &amp;&amp; orderItemSeqId &amp;&amp; shipmentId">
                <entity-find entity-name="mantle.order.OrderItemBilling" list="orderItemBillingList">
                    <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/>
                    <econdition field-name="shipmentId"/><econdition field-name="assetReceiptId" from="null"/>
                </entity-find>
                <iterate list="orderItemBillingList" entry="orderItemBilling">
                    <set field="orderItemBilling.assetReceiptId" from="assetReceiptId"/>
                    <entity-update value-field="orderItemBilling"/>
                </iterate>
            </if>

            <!-- create AssetDetail -->
            <set field="availableToPromiseDiff" from="statusId == 'AstAvailable' ? quantity : 0"/>
            <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                    in-map="[assetId:assetId, effectiveDate:receivedDate, quantityOnHandDiff:quantity,
                        availableToPromiseDiff:availableToPromiseDiff, unitCost:orderItem?.unitAmount,
                        shipmentId:shipmentId, productId:productId, returnId:returnId, returnItemSeqId:returnItemSeqId,
                        workEffortId:workEffortId, assetReceiptId:assetReceiptId]"/>

            <!-- call through AssetDetail create? NO, would get called from the move#AssetReservation record recursively -->
            <!-- reserve the newly available Asset, if needed -->
            <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/>
        </actions>
    </service>

    <service verb="update" noun="AssetAndReceipt">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="assetReceiptId"><description>If not specified will look it up with assetId and shipmentId.</description></parameter>
            <parameter name="shipmentId"/>
            <auto-parameters entity-name="mantle.product.receipt.AssetReceipt" include="nonpk"/>
            <auto-parameters entity-name="mantle.product.asset.AssetDetail" include="nonpk">
                <exclude field-name="availableToPromiseDiff"/>
                <exclude field-name="quantityOnHandDiff"/>
            </auto-parameters>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk">
                <exclude field-name="availableToPromiseTotal"/>
                <exclude field-name="quantityOnHandTotal"/>
            </auto-parameters>
        </in-parameters>
        <out-parameters><parameter name="assetDetailId"/></out-parameters>
        <actions>
            <!-- update the AssetReceipt -->
            <if condition="!assetReceiptId">
                <entity-find entity-name="mantle.product.receipt.AssetReceipt" list="assetReceiptList">
                    <econdition field-name="assetId"/><econdition field-name="shipmentId"/>
                    <order-by field-name="assetReceiptId"/>
                </entity-find>
                <set field="originalAssetReceipt" from="assetReceiptList?.first"/>
                <set field="assetReceiptId" from="originalAssetReceipt?.assetReceiptId"/>

                <else>
                    <entity-find-one entity-name="mantle.product.receipt.AssetReceipt" value-field="originalAssetReceipt"/>
                </else>
            </if>
            <if condition="!assetReceiptId"><return error="true" message="Cannot update Asset and Receipt, could not find AssetReceipt record for assetId [${assetId}], shipmentId [${shipmentId}]"/></if>

            <!-- calculate the quantityAccepted difference, will be set in quantityOnHandDiff and availableToPromiseDiff -->
            <set field="quantityDiff" from="(quantityAccepted ?: originalAssetReceipt.quantityAccepted) - originalAssetReceipt.quantityAccepted"/>
            <set field="quantityRejectedDiff" from="(quantityRejected ?: originalAssetReceipt.quantityRejected) - originalAssetReceipt.quantityRejected"/>

            <!-- <log level="warn" message="======= quantityAccepted ${quantityAccepted}, quantityRejected ${quantityRejected}, quantityDiff ${quantityDiff}, originalAssetReceipt: ${originalAssetReceipt}"/> -->

            <!-- Ensure the ShipmentItem has sufficient remaining quantity -->
            <set field="newQuantityRemaining" from="(quantityDiff ?: 0) + (quantityRejectedDiff ?: 0)"/>
            <if condition="newQuantityRemaining">
                <service-call name="mantle.shipment.ShipmentServices.ensure#ShipmentItemQuantityRemaining"
                        in-map="[shipmentId:shipmentId, productId:productId, newQuantityRemaining:newQuantityRemaining]"/>
            </if>

            <!-- TODO: if quantityAccepted is updated and GL entry exists adjust the GL! -->
            <service-call name="update#mantle.product.receipt.AssetReceipt" in-map="context" out-map="context"/>

            <!-- TODO: if acquireCost is updated adjust the GL, if set from null do GL posting! -->
            <service-call name="update#mantle.product.asset.Asset" in-map="context" out-map="context"/>

            <if condition="quantityDiff != 0">
                <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="context"/>
            </if>
        </actions>
    </service>
    <service verb="replace" noun="AssetPartyAssignment">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="roleTypeId" required="true"/>
            <parameter name="newPartyId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.product.asset.AssetPartyAssignment" list="apaList">
                <date-filter/><econdition field-name="assetId"/><econdition field-name="roleTypeId"/>
            </entity-find>
            <set field="foundExisting" from="false"/>
            <iterate list="apaList" entry="apaValue">
                <if condition="apaValue.partyId != newPartyId">
                    <set field="apaValue.thruDate" from="ec.user.nowTimestamp"/>
                    <entity-update value-field="apaValue"/>

                    <else><set field="foundExisting" from="true"/></else>
                </if>
            </iterate>
            <if condition="!foundExisting">
                <service-call name="create#mantle.product.asset.AssetPartyAssignment" in-map="[assetId:assetId,
                    partyId:newPartyId, roleTypeId:roleTypeId, fromDate:ec.user.nowTimestamp]"/>
            </if>
        </actions>
    </service>

    <service verb="record" noun="PhysicalInventoryQuantity">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="locationSeqId"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="partyId" default="ec.user.userAccount.partyId"/>
            <parameter name="physicalInventoryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="comments"/>
            <parameter name="varianceReasonEnumId"/>
        </in-parameters>
        <out-parameters><parameter name="physicalInventoryId"/></out-parameters>
        <actions>
            <set field="currentQoh" from="0"/>
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/><econdition field-name="facilityId"/>
                <econdition field-name="quantityOnHandTotal" operator="not-equals" from="0"/>
                <econdition field-name="locationSeqId" ignore-if-empty="true"/>
            </entity-find>
            <iterate list="assetList" entry="asset"><set field="currentQoh" from="currentQoh + asset.quantityOnHandTotal"/></iterate>

            <set field="quantityChange" from="quantity - currentQoh"/>
            <service-call name="mantle.product.AssetServices.record#PhysicalInventoryChange" in-map="context"/>
        </actions>
    </service>
    <service verb="record" noun="PhysicalInventoryChange">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="locationSeqId"/>
            <parameter name="quantityChange" type="BigDecimal" required="true"/>
            <parameter name="partyId" default="ec.user.userAccount.partyId"/>
            <parameter name="physicalInventoryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="comments"/>
            <parameter name="varianceReasonEnumId"/>
            <parameter name="assetList" type="EntityList"><description>Optional, meant to be used when called by other physical inventory services.</description></parameter>
        </in-parameters>
        <out-parameters><parameter name="physicalInventoryId"/></out-parameters>
        <actions>
            <!-- set the date to be used on AssetDetail records -->
            <set field="effectiveDate" from="physicalInventoryDate"/>
            <!-- create the PhysicalInventory inventory record -->
            <service-call name="create#mantle.product.asset.PhysicalInventory" in-map="context" out-map="context"/>

            <if condition="!assetList">
                <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                    <econdition field-name="productId"/><econdition field-name="facilityId"/>
                    <econdition field-name="quantityOnHandTotal" operator="not-equals" from="0"/>
                    <econdition field-name="locationSeqId" ignore-if-empty="true"/>
                </entity-find>
            </if>
            <if condition="quantityChange &gt; 0">
                <!-- if adding inventory order assetList by -receivedDate to add to most recent first, otherwise by receivedDate to subtract from oldest first -->
                <order-map-list list="assetList"><order-by field-name="-receivedDate"/></order-map-list>
                <set field="quantityRemaining" from="quantityChange"/>
                <iterate list="assetList" entry="asset">
                    <set field="quantityDiff" from="quantityRemaining &gt; asset.quantityOnHandTotal ? asset.quantityOnHandTotal : quantityRemaining"/>
                    <if condition="quantityDiff != 0">
                        <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="context + [assetId:asset.assetId]"/></if>
                    <set field="quantityRemaining" from="quantityRemaining - quantityDiff"/>
                    <if condition="quantityRemaining == 0"><break/></if>
                </iterate>

                <else-if condition="quantityChange &lt; 0">
                    <order-map-list list="assetList"><order-by field-name="receivedDate"/></order-map-list>
                    <set field="quantityRemaining" from="-quantityChange"/>
                    <iterate list="assetList" entry="asset">
                        <set field="quantityDiff" from="quantityRemaining &gt; asset.quantityOnHandTotal ? asset.quantityOnHandTotal : quantityRemaining"/>
                        <if condition="quantityDiff != 0">
                            <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="context +
                                    [assetId:asset.assetId, quantityDiff:-quantityDiff]"/></if>
                        <set field="quantityRemaining" from="quantityRemaining - quantityDiff"/>
                        <if condition="quantityRemaining == 0"><break/></if>
                    </iterate>
                </else-if>
            </if>
        </actions>
    </service>
</services>
