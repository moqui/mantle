<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-1.5.xsd">

    <!-- Service for export of NACHA files (see https://www.nacha.org) -->

    <service verb="generate" noun="NachaFile">
        <in-parameters>
            <parameter name="paymentMethodId" required="true"/>
            <parameter name="fromDate" type="Timestamp"><description>If null no limit on look back</description></parameter>
            <parameter name="thruDate" type="Timestamp" default="ec.user.nowTimestamp">
                <description>If null look through now</description></parameter>
            <parameter name="fileDate" type="Timestamp" default="ec.user.nowTimestamp"><description>The date/time used
                in various fields and set on PaymentMethodFile.fileDate</description></parameter>
            <parameter name="effectiveEntryDate" type="Date"><description>Transaction settle/post date, should be at
                least one business day in the future and should not be a weekend day or bank holiday. If not specified
                the next week day after fileDate is used.</description></parameter>
            <parameter name="nachaEntryDescription"><description>Overrides BankAccount.nachaEntryDescription</description></parameter>
            <parameter name="fileTypeEnumId" default-value="PmftNacha"/>
        </in-parameters>
        <out-parameters>
            <parameter name="paymentMethodFileId"/>
            <parameter name="fileText"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.method.PaymentMethod" value-field="paymentMethod"/>
            <entity-find-one entity-name="mantle.account.method.BankAccount" value-field="bankAccount"/>
            <if condition="!bankAccount"><return error="true" message="Payment method [${paymentMethodId}] is not a bank account"/></if>

            <!-- find applicable payments (match fromPartyId and statusId=PmntAuthorized, or toPartyId and PmntPromised) -->
            <entity-find entity-name="mantle.account.payment.Payment" list="paymentList" for-update="true">
                <econditions combine="or">
                    <econditions combine="and">
                        <econdition field-name="fromPartyId" from="paymentMethod.ownerPartyId"/>
                        <econdition field-name="statusId" value="PmntAuthorized"/>
                        <econdition field-name="paymentMethodId"/>
                        <econdition field-name="toPaymentMethodId" operator="not-equals" from="null"/>
                    </econditions>
                    <econditions combine="and">
                        <econdition field-name="toPartyId" from="paymentMethod.ownerPartyId"/>
                        <econdition field-name="statusId" value="PmntPromised"/>
                        <econdition field-name="toPaymentMethodId" from="paymentMethodId"/>
                        <econdition field-name="paymentMethodId" operator="not-equals" from="null"/>
                    </econditions>
                </econditions>
                <econdition field-name="paymentInstrumentEnumId" value="PiAch"/>
                <econdition field-name="paymentMethodFileId" from="null"/>
                <order-by field-name="effectiveDate"/>
            </entity-find>

            <!-- no payments? return now with a message -->
            <if condition="!paymentList"><return message="No pending ACH payments found for payment method [${paymentMethodId}]"/></if>

            <!-- count of files sent today for File ID Modifier in File Header char 34 -->
            <set field="todayRange" from="ec.user.getPeriodRange('day', '0')"/>
            <entity-find-count entity-name="mantle.account.method.PaymentMethodFile" count-field="fileCount">
                <econdition field-name="fileDate" operator="greater-equals" from="todayRange[0]"/>
                <econdition field-name="fileDate" operator="less-equals" from="todayRange[1]"/>
            </entity-find-count>
            <if condition="fileCount &gt; 35"><message error="true">More than 35 files not allowed in one day (payment method [${paymentMethodId}]), found ${fileCount}</message></if>

            <!-- set/check some configuration values -->

            <!-- File Header fields -->
            <if condition="!bankAccount.nachaImmedDest || bankAccount.nachaImmedDest.length() != 9">
                <message error="true">NACHA Immediate Destination field (${bankAccount.nachaImmedDest}) on Bank Account must be 9 characters</message></if>
            <if condition="!bankAccount.nachaImmedOrig || bankAccount.nachaImmedOrig.length() != 9">
                <message error="true">NACHA Immediate Origin field (${bankAccount.nachaImmedOrig}) on Bank Account must be 9 characters</message></if>
            <set field="nachaImmedDestName" from="bankAccount.nachaImmedDestName ?: bankAccount.bankName"/>
            <if condition="!nachaImmedDestName || nachaImmedDestName.length() &gt; 23">
                <message error="true">NACHA Immediate Destination Name field (${nachaImmedDestName}) on Bank Account must be specified and not more than 23 characters</message></if>
            <set field="nachaImmedOrigName" from="bankAccount.nachaImmedOrigName ?: paymentMethod.companyNameOnAccount"/>
            <if condition="!nachaImmedOrigName || nachaImmedOrigName.length() &gt; 23">
                <message error="true">NACHA Immediate Origin Name field (${nachaImmedOrigName}) on Bank Account must be specified and not more than 23 characters</message></if>

            <!-- Batch Header fields -->
            <set field="nachaCompanyName" from="bankAccount.nachaCompanyName"/>
            <if condition="!nachaCompanyName">
                <set field="nachaCompanyName" from="paymentMethod.companyNameOnAccount"/>
                <if condition="nachaCompanyName?.length() > 16"><set field="nachaCompanyName" from="nachaCompanyName.substring(0, 16)"/></if>
            </if>
            <if condition="!nachaCompanyName || nachaCompanyName.length() &gt; 16">
                <message error="true">NACHA Company Name field (${nachaCompanyName}) on Bank Account must be specified and not more than 16 characters</message></if>
            <set field="nachaDiscrData" from="bankAccount.nachaDiscrData ?: ''"/>
            <if condition="nachaDiscrData.length() &gt; 20">
                <message error="true">NACHA Discretionary Data field (${nachaDiscrData}) on Bank Account must not be more than 20 characters</message></if>
            <if condition="!bankAccount.nachaCompanyId || bankAccount.nachaCompanyId.length() &gt; 10">
                <message error="true">NACHA Company ID field (${bankAccount.nachaCompanyId}) on Bank Account must be specified and not more than 10 characters</message></if>
            <set field="nachaEntryDescription" from="nachaEntryDescription ?: bankAccount.nachaEntryDescription"/>
            <if condition="!nachaEntryDescription || nachaEntryDescription.length() &gt; 10">
                <message error="true">NACHA Entry Description field (${nachaEntryDescription}) on Bank Account or service parameter must be specified and not more than 10 characters</message></if>

            <if condition="!effectiveEntryDate"><script><![CDATA[
                Calendar entryCal = ec.user.nowCalendar
                entryCal.setTime(fileDate)
                entryCal.add(Calendar.DAY_OF_MONTH, 1)
                if (entryCal.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY) {
                    entryCal.add(Calendar.DAY_OF_MONTH, 2)
                } else if (entryCal.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
                    entryCal.add(Calendar.DAY_OF_MONTH, 1)
                }
                // FUTURE: check for holiday (observed bank holiday) and increment accordingly
                effectiveEntryDate = entryCal
            ]]></script></if>

            <check-errors/>

            <!-- create a PaymentMethodFile record, get the paymentMethodFileId (used in the file) -->
            <service-call name="create#mantle.account.method.PaymentMethodFile" in-map="context" out-map="context"/>

            <!-- generate the NACHA file -->
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.entity.EntityValue
                ExecutionContext ec = context.ec

                // Handy output checking lines, paste below to line up output
                // 0        10        20        30        40        50        60        70        80        90
                // 123456789+123456789+123456789+123456789+123456789+123456789+123456789+123456789+123456789+1234

                List<StringBuilder> lines = []

                // File Header (1)
                StringBuilder fileHeader = new StringBuilder(94)
                // 01-01: Record Type Code = '1'
                // 02-03: Priority Code = '01'
                fileHeader.append("101")
                // 04-13: Immediate Destination (space + 9 digits as TTTTAAAAC, really whatever bank specifies)
                fileHeader.append(" ").append(bankAccount.nachaImmedDest)
                // 14-23: Immediate Origin (space + 9 digits)
                fileHeader.append(" ").append(bankAccount.nachaImmedOrig)
                // 24-29: File Creation Date
                fileHeader.append(ec.l10n.format(fileDate, "yyMMdd"))
                // 30-33: File Creation Time
                fileHeader.append(ec.l10n.format(fileDate, "HHmm"))
                // 34-34: File ID Modifier (count of files for the day)
                fileHeader.append(Character.toUpperCase(Character.forDigit((int) fileCount, 36)))
                // 35-37: Record Size: '094'
                // 38-39: Blocking Factor: '10'
                // 40-40: Format Code: '1'
                fileHeader.append("094101")
                // 41-63: Immediate Destination Name
                fileHeader.append(nachaImmedDestName.toUpperCase().padRight(23, ' '))
                // 64-86: Immediate Origin Name
                fileHeader.append(nachaImmedOrigName.toUpperCase().padRight(23, ' '))
                // 87-94: Reference Code, not used, just 8 spaces
                fileHeader.append(" ".padRight(8, ' '))
                lines.add(fileHeader)

                // Batch Header (5)
                StringBuilder batchHeader = new StringBuilder(94)
                // 01-01: Record Type Code = '5'
                // 02-04: Service Class Code = '200'
                batchHeader.append("5200")
                // 05-20: Company Name (16 chars)
                batchHeader.append(nachaCompanyName.toUpperCase().padRight(16, ' '))
                // 21-40: Company discretionary data (20 chars)
                batchHeader.append(nachaDiscrData.toUpperCase().padRight(20, ' '))
                // 41-50: Company ID
                batchHeader.append(bankAccount.nachaCompanyId.toUpperCase().padRight(10, ' '))
                // 51-53: Standard Entry Class Code: always use PPD (Prearranged Payment and Deposit) for now, future consider support for CCD, TEL, WEB, etc
                batchHeader.append("PPD")
                // 54-63: Company Entry Description (for receiver's bank account, 10 chars)
                batchHeader.append(nachaEntryDescription.toUpperCase().padRight(10, ' '))
                // 64-69: Company Descriptive Date (6 chars); note that this is informational and optional
                batchHeader.append(ec.l10n.format(fileDate, "MMM dd").toUpperCase())
                // 70-75: Effective Entry Date (estimated settlement date, 1 business day later; 6 chars at yyMMdd)
                batchHeader.append(ec.l10n.format(effectiveEntryDate, "yyMMdd"))
                // 76-78: Settlement Date (leave blank, 3 spaces)
                batchHeader.append(" ".padRight(3, ' '))
                // 79-79: Originator Status Code = '1'
                batchHeader.append("1")
                // 80-87: Originating DFI Identification; same as Immediate Destination, last character trimmed for 8 chars
                batchHeader.append(bankAccount.nachaImmedDest.substring(0, 8))
                // 88-94: Batch Number (7 chars); always "0000001" since we're doing one batch per file, future: for multiple batches increment this per batch header
                batchHeader.append("1".padLeft(7, '0'))

                lines.add(batchHeader)

                // Entry Detail (6) & Addenda (7)
                int entryCount = 0
                long routingNumberSum = 0
                BigDecimal debitAmountTotal = 0, creditAmountTotal = 0
                for (EntityValue payment in paymentList) {
                    boolean outgoing = payment.fromPartyId == paymentMethod.ownerPartyId

                    // Get PaymentMethod and BankAccount; use toPaymentMethodId if outgoing
                    String pmtPaymentMethodId = outgoing ? payment.toPaymentMethodId : payment.paymentMethodId
                    EntityValue pmtPaymentMethod = ec.entity.find("mantle.account.method.PaymentMethod")
                            .condition("paymentMethodId", pmtPaymentMethodId).one()
                    EntityValue pmtBankAccount = ec.entity.find("mantle.account.method.BankAccount")
                            .condition("paymentMethodId", pmtPaymentMethodId).one()
                    if (pmtBankAccount == null) {
                        ec.message.addError("No Bank Account for payment method [${pmtPaymentMethodId}] on payment [${payment.paymentId}]")
                        continue
                    }
                    // check the routing number
                    String routingNumber = pmtBankAccount.routingNumber
                    if (!routingNumber || routingNumber.length() != 9) {
                        ec.message.addError("Routing Number is not 9 characters on Bank Account for payment method [${pmtPaymentMethodId}] on payment [${payment.paymentId}]")
                        continue
                    }
                    // calculate routing number check digit
                    String routingWeights = "37137137"
                    int routingCheckSum = 0
                    for (int i = 0; i < 8; i++) routingCheckSum += (Character.digit(routingNumber.charAt(i), 10)) * (Character.digit(routingWeights.charAt(i), 10))
                    String routingCheckDigit = (10 - (routingCheckSum % 10)) as String
                    // add first 8 digits of routingNumber to routingNumberSum
                    routingNumberSum += (routingNumber.substring(0, 8) as long)

                    // check/trim the account number
                    String accountNumber = pmtBankAccount.accountNumber
                    if (!accountNumber) {
                        ec.message.addError("Account Number is missing on Bank Account for payment method [${pmtPaymentMethodId}] on payment [${payment.paymentId}]")
                        continue
                    }
                    if (accountNumber.length() > 17) accountNumber = accountNumber.substring(0, 17)

                    // check/format payment amount
                    if (!payment.amount || payment.amount.scale() > 2) {
                        ec.message.addError("Amount [${payment.amount?.toPlainString()}] must be specified an have no more than 2 decimal digits on payment [${payment.paymentId}]")
                        continue
                    }
                    String amountStr = payment.getBigDecimal("amount").movePointRight(2).longValueExact() as String
                    if (amountStr.length() > 10) {
                        ec.message.addError("Amount [${payment.amount.toPlainString()}] is too big for NACHA transactions on payment [${payment.paymentId}]")
                        continue
                    }
                    // add to debitAmountTotal or creditAmountTotal
                    if (outgoing) creditAmountTotal += payment.amount else debitAmountTotal += payment.amount

                    // look up other party PartyDetail
                    String otherPartyId = payment.fromPartyId == paymentMethod.ownerPartyId ? payment.toPartyId : payment.fromPartyId
                    EntityValue otherParty = ec.entity.find("mantle.party.PartyDetail").condition("partyId", otherPartyId).one()

                    // get Individual/Company ID from pseudoId
                    String individualId = otherParty.pseudoId
                    if (individualId.length() > 15) individualId = individualId.substring(0, 15)

                    // get Individual/Company Name
                    String indName = pmtPaymentMethod.firstNameOnAccount ?
                            pmtPaymentMethod.firstNameOnAccount + " " + pmtPaymentMethod.lastNameOnAccount :
                            pmtPaymentMethod.companyNameOnAccount
                    if (!indName) indName = otherParty.firstName ? otherParty.firstName + " " + otherParty.lastName : otherParty.organizationName
                    // TODO: better way to truncate names?
                    if (indName.length() > 22) indName = indName.substring(0, 22)

                    // done with validation/prep, increment entryCount and create the record
                    entryCount++

                    // Entry Detail (6)
                    StringBuilder entry = new StringBuilder()
                    // 01-01: Record Type Code = '6'
                    entry.append("6")
                    // 02-03: Transaction Code: checking/etc credit '22', debit '27'; savings credit '32', debit '37'
                    if (pmtBankAccount.typeEnumId == 'BatSavings') { entry.append(outgoing ? "32" : "37") }
                    else { entry.append(outgoing ? "22" : "27") }
                    // 04-11: Receiving DFI R/T number (8 digits)
                    //     First eight digits of routing/transit number of receiving financial depository institution (RDFI)
                    //     where the transaction is to be posted. The first digit should be 0, 1, 2, or 3. An R/T number
                    //     starting with 4-9 is usually not valid.
                    entry.append(routingNumber.substring(0, 8))
                    // 12-12: R/T number check digit
                    entry.append(routingCheckDigit)
                    // 13-29: Receiving DFI account number (last 17 digits, right space padded)
                    entry.append(accountNumber.padRight(17, ' '))
                    // 30-39: Amount (10 digits, no decimal point, last 2 digits are decimal values, left pad with 0)
                    entry.append(amountStr.padLeft(10, '0'))
                    // 40-54: Individual or Company ID for company (15 chars), use Party.pseudoId
                    entry.append(individualId.toUpperCase().padRight(15, ' '))
                    // 55-76: Individual or Company Name (22 chars)
                    entry.append(indName.toUpperCase().padRight(22, ' '))
                    // 77-78: Discretionary Data (2 chars); leave blank for now, for WEB or other special transactions may need a value
                    entry.append("  ")
                    // 79-79: Addenda record indicator, always '0' since not using Addenda (7) records (would be '1' if there is one or more addenda records)
                    entry.append("0")
                    // 80-94: Trace number (15 chars); first 8 chars from Immediate Destination, plus index (entryCount zero left padded to 7 chars)
                    entry.append(bankAccount.nachaImmedDest.substring(0, 8))
                    entry.append((entryCount as String).padLeft(7, '0'))

                    lines.add(entry)

                    // FUTURE: Addenda (7) with ANSI ASC X12.4, X12.85, or other data
                }

                String routingNumberSumStr = routingNumberSum as String
                if (routingNumberSumStr.length() > 10)
                    routingNumberSumStr = routingNumberSumStr.substring(routingNumberSumStr.length() - 10, routingNumberSumStr.length())

                String debitAmountTotalStr = debitAmountTotal.movePointRight(2).longValueExact() as String
                String creditAmountTotalStr = creditAmountTotal.movePointRight(2).longValueExact() as String

                // Batch Control (8)
                StringBuilder batchControl = new StringBuilder()
                // 01-01: Record Type Code = '8'
                // 02-04: Service class code (same as batch header) = '200'
                batchControl.append("8200")
                // 05-10: Entry/addenda count (6 chars, zero left padded)
                batchControl.append((entryCount as String).padLeft(6, '0'))
                // 11-20: Entry hash (10 chars); sum of the 8-digit receiving DFI routing/transit numbers in entry
                //     detail records; zero left padded, if too long trim from left
                batchControl.append(routingNumberSumStr.padLeft(10, '0'))
                // 21-32: Total batch debit entry dollar amount (12 digits, std number format pattern)
                batchControl.append(debitAmountTotalStr.padLeft(12, '0'))
                // 33-44: Total batch credit entry dollar amount (12 digits, std number format pattern)
                batchControl.append(creditAmountTotalStr.padLeft(12, '0'))
                // 45-54: Company ID (same as in Batch Header)
                batchControl.append(bankAccount.nachaCompanyId.toUpperCase().padRight(10, ' '))
                // 55-73: Message authentication code (leave blank, 19 spaces)
                batchControl.append(" ".padRight(19, ' '))
                // 74-79: Reserverd blank (leave blank, 6 spaces)
                batchControl.append(" ".padRight(6, ' '))
                // 80-87: Originating DFI ID; first 8 chars from Immediate Destination
                batchControl.append(bankAccount.nachaImmedDest.substring(0, 8))
                // 88-94: Batch Number (7 chars); same as Batch Header; always "0000001" since we're doing one batch per file
                batchControl.append("1".padLeft(7, '0'))

                lines.add(batchControl)

                // File Control (9)
                StringBuilder fileControl = new StringBuilder()
                // 01-01: Record Type Code = '9'
                fileControl.append("9")
                // 02-07: Batch count (6 chars)
                fileControl.append("1".padLeft(6, '0'))
                // 08-13: Block count (6 chars); count of 10-line blocks (entries plus 2 header and 2 control records, divide by 10, round up)
                fileControl.append(((entryCount + 4) / 10).setScale(0, BigDecimal.ROUND_UP).toPlainString().padLeft(6, '0'))
                // 14-21: Entry/addenda record count (8 chars)
                fileControl.append((entryCount as String).padLeft(8, '0'))
                // 22-31: Entry hash total (10 chars); since we have 1 batch same as value in Batch Control
                fileControl.append(routingNumberSumStr.padLeft(10, '0'))
                // 32-43: Total file debit entry amount (12 digits)
                fileControl.append(debitAmountTotalStr.padLeft(12, '0'))
                // 44-55: Total file credit entry amount (12 digits)
                fileControl.append(creditAmountTotalStr.padLeft(12, '0'))
                // 56-94: Filler (39 spaces)
                fileControl.append(" ".padRight(39, ' '))

                lines.add(fileControl)

                // if not a multiple of 10 lines add lines of all 9s until it is
                while (lines.size() % 10 != 0) {
                    StringBuilder sb = new StringBuilder(94)
                    for (int i = 0; i < 94; i++) sb.append('9')
                    lines.add(sb)
                }
                // combines the lines
                StringBuilder ftSb = new StringBuilder(95 * lines.size())
                for (StringBuilder line in lines) {
                    if (line.length() != 94) ec.message.addError("Generated line does not have exactly 94 chars: ${line}")
                    ftSb.append(line).append('\n')
                }
                // get the String value
                fileText = ftSb.toString()
            ]]></script>

            <check-errors/>

            <!-- TODO set paymentMethodFileId on all Payment records -->
            <!-- TODO for outgoing Payment (credit) update statusId to PmntDelivered -->
            <!-- TODO for incoming Payment (debit) update statusId to PmntAuthorized or PmntDelivered? -->

            <!-- save full file text, etc to PaymentMethodFile -->
            <service-call name="update#mantle.account.method.PaymentMethodFile"
                    in-map="[paymentMethodFileId:paymentMethodFileId, entryCount:entryCount,
                        debitAmountTotal:debitAmountTotal, creditAmountTotal:creditAmountTotal, fileText:fileText]"/>
        </actions>
    </service>
</services>
