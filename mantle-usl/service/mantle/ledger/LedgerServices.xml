<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-1.5.xsd">

    <service verb="create" noun="GlAccount" type="entity-auto">
        <in-parameters>
            <auto-parameters entity-name="mantle.ledger.account.GlAccount"/>
            <parameter name="glAccountId" default="accountCode"/>
            <parameter name="accountCode" required="true"/>
            <parameter name="accountName" required="true"/>
            <parameter name="glAccountClassEnumId" required="true"/>
            <parameter name="glResourceTypeEnumId" default-value="GlrtMoney"/>
        </in-parameters>
        <out-parameters><parameter name="glAccountId"/></out-parameters>
    </service>

    <service verb="init" noun="PartyAccountingConfiguration">
        <in-parameters>
            <parameter name="sourcePartyId" required="true"/>
            <parameter name="organizationPartyId" required="true"/>
            <auto-parameters entity-name="mantle.ledger.config.PartyAcctgPreference" include="nonpk"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="existingPartyAcctgPreference">
                <field-map field-name="organizationPartyId"/>
            </entity-find-one>
            <if condition="existingPartyAcctgPreference">
                <return message="Party [${organizationPartyId}] already has a PartyAcctgPreference record, so not initializing accounting configuration."/>
            </if>

            <!-- create an error Journal mantle.ledger.transaction.GlJournal -->
            <entity-find-one entity-name="mantle.party.Organization" value-field="organization">
                <field-map field-name="partyId" from="organizationPartyId"/></entity-find-one>
            <set field="errorGlJournalId" value="${organizationPartyId}Error"/>
            <service-call name="create#mantle.ledger.transaction.GlJournal"
                    in-map="[organizationPartyId:organizationPartyId, glJournalId:errorGlJournalId,
                        glJournalTypeEnumId:'GLJRNL_ERROR', isPosted:'N',
                        glJournalName:('Error Journal for ' + (organization?.organizationName ?: organizationPartyId))]"/>

            <!-- copy the mantle.ledger.config.PartyAcctgPreference -->
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="sourcePartyAcctgPreference">
                <field-map field-name="organizationPartyId" from="sourcePartyId"/>
            </entity-find-one>
            <if condition="!sourcePartyAcctgPreference"><return error="true" message="Could not find PartyAcctgPreference for source party [${sourcePartyId}]"/></if>
            <set field="partyAcctgPreference" from="sourcePartyAcctgPreference.cloneValue()"/>
            <entity-set value-field="partyAcctgPreference" include="nonpk" set-if-empty="false"/>
            <service-call name="create#mantle.ledger.config.PartyAcctgPreference"
                    in-map="partyAcctgPreference + [organizationPartyId:organizationPartyId, errorGlJournalId:errorGlJournalId]"/>

            <!-- copy mantle.ledger.account.GlAccountOrganization -->
            <entity-find entity-name="mantle.ledger.account.GlAccountOrganization" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.AssetTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.AssetTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record">
                <set field="record.organizationPartyId" from="organizationPartyId"/>
                <set field="record.assetTypeGlAccountId" from="null"/>
                <entity-sequenced-id-primary value-field="record"/>
                <entity-create value-field="record"/>
            </iterate>

            <!-- copy mantle.ledger.config.GlAccountTypeDefault -->
            <entity-find entity-name="mantle.ledger.config.GlAccountTypeDefault" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.InvoiceTypeTransType -->
            <entity-find entity-name="mantle.ledger.config.InvoiceTypeTransType" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.ItemTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.ItemTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.PaymentTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.PaymentTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.PaymentInstrumentGlAccount -->
            <entity-find entity-name="mantle.ledger.config.PaymentInstrumentGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.FinancialAccountTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.FinancialAccountTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>
            <!-- copy mantle.ledger.config.FinancialAccountReasonGlAccount -->
            <entity-find entity-name="mantle.ledger.config.FinancialAccountReasonGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- TODO: CreditCardTypeGlAccount, GlAccountTypePartyDefault, ProductCategoryGlAccount, ProductGlAccount, TaxAuthorityGlAccount, VarianceReasonGlAccount -->

            <!-- setup mantle.party.time.TimePeriod for FiscalMonth, FiscalQuarter, FiscalYear -->
            <service-call name="mantle.ledger.LedgerServices.check#NextFiscalTimePeriods"
                    in-map="[organizationPartyId:organizationPartyId]"/>
        </actions>
    </service>

    <service verb="find" noun="PartyAcctgPreference">
        <description>Get the PartyAcctgPreference record for the specified organizationPartyId and if not found find
            record for ancestor organization(s).</description>
        <in-parameters><parameter name="organizationPartyId" required="true"/></in-parameters>
        <out-parameters><parameter name="partyAcctgPreference" type="EntityValue"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference" cache="true">
                <field-map field-name="organizationPartyId"/></entity-find-one>

            <if condition="!partyAcctgPreference">
                <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                    <date-filter/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                    <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                </entity-find>
                <if condition="partyRelationshipList">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                            in-map="[organizationPartyId:partyRelationshipList[0].toPartyId]"/>
                </if>
            </if>
        </actions>
    </service>
    <service verb="find" noun="RootGlAccountClassEnum">
        <in-parameters><parameter name="glAccountClassEnumId"/></in-parameters>
        <out-parameters><parameter name="rootGlAccountClassEnumId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue" cache="true">
                <field-map field-name="enumId" from="glAccountClassEnumId"/>
            </entity-find-one>
            <if condition="enumValue.parentEnumId">
                <service-call name="mantle.ledger.LedgerServices.find#RootGlAccountClassEnum" out-map="context"
                        in-map="[glAccountClassEnumId:enumValue.parentEnumId]"/>
                <else>
                    <set field="rootGlAccountClassEnumId" from="glAccountClassEnumId"/>
                </else>
            </if>
        </actions>
    </service>
    <service verb="expand" noun="ParentOrganizationList">
        <in-parameters><parameter name="organizationPartyId" required="true"/></in-parameters>
        <out-parameters><parameter name="orgPartyIdList" type="List"/></out-parameters>
        <actions>
            <set field="orgPartyIdList" from="[organizationPartyId]"/>

            <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                <date-filter/>
                <econdition field-name="fromPartyId" from="organizationPartyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                <econdition field-name="toRoleTypeId" value="OrgInternal"/>
            </entity-find>
            <iterate list="partyRelationshipList" entry="partyRelationship">
                <service-call name="mantle.ledger.LedgerServices.expand#ParentOrganizationList" out-map="expandResult"
                        in-map="[organizationPartyId:partyRelationship.toPartyId]"/>
                <script>orgPartyIdList.addAll(expandResult.orgPartyIdList)</script>
            </iterate>
        </actions>
    </service>
    <service verb="expand" noun="ChildOrganizationList">
        <in-parameters>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="onlyWithNoAcctgPreference" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters><parameter name="orgPartyIdList" type="List"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference" cache="true">
                <field-map field-name="organizationPartyId"/></entity-find-one>
            <if condition="onlyWithNoAcctgPreference &amp;&amp; partyAcctgPreference">
                <then><set field="orgPartyIdList" from="[]"/></then>
                <else><set field="orgPartyIdList" from="[organizationPartyId]"/></else>
            </if>

            <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                <date-filter/>
                <econdition field-name="toPartyId" from="organizationPartyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                <econdition field-name="toRoleTypeId" value="OrgInternal"/>
            </entity-find>
            <iterate list="partyRelationshipList" entry="partyRelationship">
                <if condition="onlyWithNoAcctgPreference">
                    <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference" cache="true">
                        <field-map field-name="organizationPartyId" from="partyRelationship.fromPartyId"/></entity-find-one>
                    <if condition="partyAcctgPreference"><continue/></if>
                </if>
                <service-call name="mantle.ledger.LedgerServices.expand#ChildOrganizationList" out-map="expandResult"
                        in-map="[organizationPartyId:partyRelationship.fromPartyId, onlyWithNoAcctgPreference:onlyWithNoAcctgPreference]"/>
                <script>orgPartyIdList.addAll(expandResult.orgPartyIdList)</script>
            </iterate>
        </actions>
    </service>
    <service verb="get" noun="OrganizationFiscalTimePeriods">
        <in-parameters>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="filterDate" type="Timestamp"/>
            <parameter name="timePeriodTypeId"/>
        </in-parameters>
        <out-parameters><parameter name="timePeriodList" type="List"/></out-parameters>
        <actions>
            <!-- NOTE: this one is not recursive, should really have TimePeriod associated with root parent org so just one will match -->
            <set field="filterSqlDate" from="filterDate ? new java.sql.Date(filterDate.time) : null"/>
            <entity-find entity-name="mantle.party.time.TimePeriodAndType" list="timePeriodList">
                <!-- doesn't work as needed with date fields (only date-time): <date-filter valid-date="filterSqlDate" ignore-if-empty="true"/> -->
                <econdition field-name="fromDate" operator="less-equals" from="filterSqlDate" ignore-if-empty="true"/>
                <econdition field-name="thruDate" operator="greater-equals" from="filterSqlDate" ignore-if-empty="true"/>
                <econdition field-name="periodPurposeEnumId" value="Fiscal" ignore="timePeriodTypeId"/>
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="timePeriodTypeId" ignore-if-empty="true"/>
            </entity-find>

            <if condition="!timePeriodList">
                <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                    <date-filter/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                    <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                </entity-find>
                <if condition="partyRelationshipList">
                    <service-call name="mantle.ledger.LedgerServices.get#OrganizationFiscalTimePeriods" out-map="parentPeriodsOut"
                            in-map="[organizationPartyId:partyRelationshipList[0].toPartyId, filterDate:filterDate,
                                timePeriodTypeId:timePeriodTypeId]"/>
                    <set field="parentOrgPeriodList" from="parentPeriodsOut.timePeriodList"/>

                    <!-- if periods are from a parent org, create clone for this org -->
                    <set field="timePeriodList" from="[]"/>
                    <!-- go through periods largest to smallest to set parent -->
                    <set field="timePeriodTypeIdList" from="['FiscalYear', 'FiscalQuarter', 'FiscalMonth', 'FiscalBiWeek', 'FiscalWeek']"/>
                    <set field="parentPeriodId" from="null"/>
                    <iterate list="timePeriodTypeIdList" entry="timePeriodTypeId">
                        <filter-map-list list="parentOrgPeriodList" to-list="matchPeriodList">
                            <field-map field-name="timePeriodTypeId"/></filter-map-list>

                        <if condition="matchPeriodList">
                            <set field="parentOrgPeriod" from="matchPeriodList[0]"/>
                            <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                                    in-map="[partyId:organizationPartyId, timePeriodTypeId:parentOrgPeriod.timePeriodTypeId,
                                        fromDate:parentOrgPeriod.fromDate, parentPeriodId:parentPeriodId]"/>
                            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod">
                                <field-map field-name="timePeriodId" from="createTpOut.timePeriodId"/></entity-find-one>
                            <script>timePeriodList.add(timePeriod)</script>
                            <set field="parentPeriodId" from="createTpOut.timePeriodId"/>
                        </if>
                    </iterate>
                </if>
            </if>
        </actions>
    </service>

    <service verb="get" noun="DefaultGlAccountByType">
        <in-parameters>
            <parameter name="glAccountTypeEnumId" required="true"/>
            <!-- <parameter name="acctgTransTypeEnumId" required="true"/> -->
            <parameter name="organizationPartyId" required="true"/>
            <!-- <parameter name="otherPartyId"/> -->
        </in-parameters>
        <out-parameters>
            <parameter name="glAccountId"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.ledger.config.GlAccountTypeDefault" list="glAccountTypeDefaultList" cache="true">
                <econdition field-name="organizationPartyId"/>
                <econdition field-name="glAccountTypeEnumId"/>
            </entity-find>
            <set field="glAccountId" from="glAccountTypeDefaultList.first?.glAccountId"/>

            <if condition="!glAccountId">
                <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                    <date-filter/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                    <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                </entity-find>
                <if condition="partyRelationshipList">
                    <service-call name="mantle.ledger.LedgerServices.get#DefaultGlAccountByType" out-map="context"
                            in-map="[organizationPartyId:partyRelationshipList[0].toPartyId,
                                glAccountTypeEnumId:glAccountTypeEnumId]"/>
                </if>
            </if>
        </actions>
    </service>

    <!-- ============================================================ -->
    <!-- ========== Manual Accounting Transaction Services ========== -->
    <!-- ============================================================ -->

    <service verb="create" noun="AcctgTrans">
        <in-parameters>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTrans" include="nonpk">
                <exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
            <parameter name="acctgTransTypeEnumId" required="true"/>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="transactionDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="amountUomId" default-value="USD"/>
            <parameter name="glFiscalTypeEnumId" default-value="GLFT_ACTUAL"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransId"/></out-parameters>
        <actions>
            <set field="isPosted" value="N"/>
            <service-call name="create#mantle.ledger.transaction.AcctgTrans" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="AcctgTrans">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTrans" include="nonpk">
                <exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot update transaction [${acctgTransId}], already posted."/></if>
            <service-call name="update#mantle.ledger.transaction.AcctgTrans" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="delete" noun="AcctgTrans">
        <in-parameters><parameter name="acctgTransId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>

            <if condition="acctgTrans.isPosted == 'Y'">
                <return error="true" message="Not deleting transaction [${acctgTransId}], transaction is posted"/></if>

            <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTransEntry">
                <econdition field-name="acctgTransId"/></entity-delete-by-condition>
            <entity-delete value-field="acctgTrans"/>
        </actions>
    </service>

    <service verb="create" noun="AcctgTransEntry">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTrans" type="EntityValue"/>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTransEntry" include="nonpk"/>
            <parameter name="debitCreditFlag" required="true"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
            <!-- allow setting this to be deferred <parameter name="glAccountId" required="true"/> -->
            <parameter name="reconcileStatusId" default-value="AterNot"/>
            <parameter name="isSummary" default-value="N"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransEntrySeqId"/></out-parameters>
        <actions>
            <if condition="!acctgTrans"><entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/></if>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot create entry for transaction [${acctgTransId}], already posted."/></if>
            <if condition="amount &lt; 0">
                <!-- if negative abs the amount and reverse the debit/credit flag -->
                <set field="amount" from="amount.abs()"/>
                <set field="debitCreditFlag" from="debitCreditFlag == 'D' ? 'C' : 'D'"/>
            </if>
            <service-call name="create#mantle.ledger.transaction.AcctgTransEntry" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="AcctgTransEntry">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTransEntrySeqId" required="true"/>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTransEntry" include="nonpk"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot update entry for transaction [${acctgTransId}], already posted."/></if>
            <service-call name="update#mantle.ledger.transaction.AcctgTransEntry" in-map="context"/>
        </actions>
    </service>
    <service verb="delete" noun="AcctgTransEntry">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTransEntrySeqId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot delete entry for transaction [${acctgTransId}], already posted."/></if>
            <service-call name="delete#mantle.ledger.transaction.AcctgTransEntry" in-map="context"/>
        </actions>
    </service>

    <!-- ================================================= -->
    <!-- ========== AcctgTrans Posting Services ========== -->
    <!-- ================================================= -->

    <service verb="calculate" noun="AcctgTransTrialBalance">
        <description>Add up debits and credits for an AcctgTrans and get the difference.</description>
        <in-parameters><parameter name="acctgTransId" required="true"/></in-parameters>
        <out-parameters>
            <parameter name="debitTotal" type="BigDecimal"/>
            <parameter name="creditTotal" type="BigDecimal"/>
            <parameter name="debitCreditDifference" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry" list="acctgTransEntryList">
                <econdition field-name="acctgTransId"/>
                <order-by field-name="acctgTransEntrySeqId"/>
            </entity-find>
            <set field="debitTotal" from="0"/>
            <set field="creditTotal" from="0"/>
            <iterate entry="acctgTransEntry" list="acctgTransEntryList">
                <if condition="acctgTransEntry.debitCreditFlag == 'D'">
                    <then><set field="debitTotal" from="debitTotal + acctgTransEntry.amount"/></then>
                    <else><set field="creditTotal" from="creditTotal + acctgTransEntry.amount"/></else>
                </if>
            </iterate>

            <set field="debitCreditDifference" from="debitTotal - creditTotal"/>
        </actions>
    </service>
    <service verb="post" noun="AcctgTrans">
        <description>Posts an Accounting Transaction (AcctgTrans) after verifying it is ready for posting (with
            verify#AcctgTrans service).</description>
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="verifyOnly" type="Boolean" default-value="false"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>

            <!-- make sure the AcctgTrans has not already been posted -->
            <if condition="acctgTrans.isPosted == 'Y'">
                <return error="true" message="Not posting transaction [${acctgTransId}], already posted."/></if>

            <set field="useErrorJournal" from="false"/>

            <!-- check the scheduled posting date, but only if it's set -->
            <if condition="acctgTrans.scheduledPostingDate != null &amp;&amp; ec.user.nowTimestamp.before(acctgTrans.scheduledPostingDate)">
                <message>Not posting transaction [${acctgTransId}], before scheduled posting date.</message>
                <set field="useErrorJournal" from="true"/>
            </if>

            <!-- check trial balance -->
            <service-call name="mantle.ledger.LedgerServices.calculate#AcctgTransTrialBalance" out-map="context"
                    in-map="[acctgTransId:acctgTransId]"/>
            <if condition="debitTotal != creditTotal">
                <message>Not posting transaction [${acctgTransId}], credit total (${creditTotal}) and debit total (${debitTotal}) not equal.</message>
                <set field="useErrorJournal" from="true"/>
            </if>

            <!-- do a for-update query on each GlAccount, make sure accounts allow posting -->
            <set field="glAccountById" from="[:]"/>
            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry" list="acctgTransEntryList">
                <econdition field-name="acctgTransId"/>
                <order-by field-name="acctgTransEntrySeqId"/>
            </entity-find>
            <iterate list="acctgTransEntryList" entry="acctgTransEntry">
                <set field="glAccount" from="glAccountById.get(acctgTransEntry.glAccountId)"/>
                <if condition="!glAccount">
                    <entity-find-one entity-name="mantle.ledger.account.GlAccount" value-field="glAccount" for-update="true">
                        <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/></entity-find-one>
                    <script>glAccountById.put(acctgTransEntry.glAccountId, glAccount)</script>
                </if>

                <if condition="glAccount.disallowPosting == 'Y'">
                    <message>GL Account ${glAccount.glAccountId} does not allow posting</message>
                    <log level="info" message="In AcctgTransEntry [${acctgTransId}:${acctgTransEntry.acctgTransEntrySeqId}] GL Account ${glAccount.glAccountId} does not allow posting"/>
                    <set field="useErrorJournal" from="true"/>
                </if>
            </iterate>

            <if condition="useErrorJournal">
                <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                        in-map="[organizationPartyId:acctgTrans.organizationPartyId]"/>
                <if condition="partyAcctgPreference?.errorGlJournalId">
                    <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                            in-map="[acctgTransId:acctgTransId, glJournalId:partyAcctgPreference.errorGlJournalId]"/>
                    <message>Accounting transaction [${acctgTransId}] has been saved in the Error Journal [${partyAcctgPreference.errorGlJournalId}].</message>
                    <return/>

                    <!-- if no errorGlJournalId return error -->
                    <else><return error="true" message="No error journal, returning error instead"/></else>
                </if>
            </if>

            <!-- get current period(s) and check if closed (also include parent organizations) -->
            <service-call name="mantle.ledger.LedgerServices.get#OrganizationFiscalTimePeriods" out-map="context"
                    in-map="[organizationPartyId:acctgTrans.organizationPartyId, filterDate:acctgTrans.transactionDate]"/>
            <if condition="!timePeriodList">
                <message error="true">Not posting transaction [${acctgTransId}], could not find time period.</message>
            </if>
            <!-- lock each time period and make sure it's not closed -->
            <iterate entry="timePeriodFromList" list="timePeriodList">
                <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod" for-update="true">
                    <field-map field-name="timePeriodId" from="timePeriodFromList.timePeriodId"/></entity-find-one>
                <if condition="timePeriod.isClosed == 'Y'">
                    <message error="true">Not posting transaction [${acctgTransId}], time period closed ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}.</message>
                </if>
            </iterate>

            <!-- make sure the glAccountId and amount fields are set -->
            <iterate entry="acctgTransEntry" list="acctgTransEntryList">
                <if condition="!acctgTransEntry.glAccountId">
                    <message error="true">Accounting transaction [${acctgTransId}] entry [${acctgTransEntry.acctgTransEntrySeqId}] has no glAccountId.</message>
                </if>
                <if condition="acctgTransEntry.amount == null">
                    <message error="true">Accounting transaction [${acctgTransId}] entry [${acctgTransEntry.acctgTransEntrySeqId}] has no amount.</message>
                </if>
            </iterate>

            <if condition="verifyOnly">
                <if condition="!ec.message.hasError()">
                    <message>Accounting transaction [${acctgTransId}] is verified for posting.</message>
                </if>
                <return/>
            </if>

            <if condition="ec.message.hasError()">
                <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                        in-map="[organizationPartyId:acctgTrans.organizationPartyId]"/>
                <if condition="partyAcctgPreference?.errorGlJournalId">
                    <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                            in-map="[acctgTransId:acctgTransId, glJournalId:partyAcctgPreference.errorGlJournalId]"/>
                    <message>Accounting transaction [${acctgTransId}] has been saved in the Error Journal [${partyAcctgPreference.errorGlJournalId}].</message>
                    <script>ec.message.clearErrors()</script>
                    <return/>

                    <!-- if not errorGlJournalId return errors -->
                    <else><check-errors/></else>
                </if>
            </if>


            <!-- for each entry update posted balance -->
            <iterate list="acctgTransEntryList" entry="acctgTransEntry">
                <!-- have already iterated through the entry list once, all GlAccount records should be there -->
                <set field="glAccount" from="glAccountById.get(acctgTransEntry.glAccountId)"/>

                <entity-find-one entity-name="mantle.ledger.account.GlAccountOrganization" value-field="glAccountOrganization" for-update="true">
                    <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/>
                    <field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/>
                </entity-find-one>
                <if condition="!glAccountOrganization">
                    <entity-make-value entity-name="mantle.ledger.account.GlAccountOrganization" value-field="glAccountOrganization"
                            map="[glAccountId:acctgTransEntry.glAccountId,  organizationPartyId:acctgTrans.organizationPartyId]"/>
                </if>

                <!-- Debits add to debit accounts and subtract from credit accounts. Credits add to credit accounts and subtract from debit accounts. -->
                <set field="postingAmount" from="0.0"/>
                <service-call name="mantle.ledger.LedgerServices.find#RootGlAccountClassEnum" out-map="context"
                        in-map="[glAccountClassEnumId:glAccount.glAccountClassEnumId]"/>

                <if condition="rootGlAccountClassEnumId == 'DEBIT'">
                    <then><set field="postingAmount" from="acctgTransEntry.debitCreditFlag == 'D' ? acctgTransEntry.amount : -acctgTransEntry.amount"/></then>
                    <else><set field="postingAmount" from="acctgTransEntry.debitCreditFlag == 'D' ? -acctgTransEntry.amount : acctgTransEntry.amount"/></else>
                </if>

                <!-- TODO: do anything with RESOURCE or potentially other root GL account classes? -->

                <set field="glAccount.postedBalance" from="(glAccount.postedBalance ?: 0) + postingAmount"/>
                <entity-update value-field="glAccount"/>
                <set field="glAccountOrganization.postedBalance" from="(glAccountOrganization.postedBalance ?: 0) + postingAmount"/>
                <entity-create value-field="glAccountOrganization" or-update="true"/>
                
                
                <!-- create or update GlAccountHistory records -->
                <iterate list="timePeriodList" entry="timePeriod">
                    <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="glAccountOrgTimePeriod" for-update="true">
                        <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/>
                        <field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/>
                        <field-map field-name="timePeriodId" from="timePeriod.timePeriodId"/>
                    </entity-find-one>
                    <if condition="glAccountOrgTimePeriod == null">
                        <entity-make-value entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="glAccountOrgTimePeriod"
                            map="[glAccountId:acctgTransEntry.glAccountId,  organizationPartyId:acctgTrans.organizationPartyId,
                                timePeriodId:timePeriod.timePeriodId, beginningBalance:0, postedDebits:0, postedCredits:0, endingBalance:0]"/>
                    </if>

                    <if condition="acctgTransEntry.debitCreditFlag == 'D'">
                        <then><set field="glAccountOrgTimePeriod.postedDebits" from="(glAccountOrgTimePeriod.postedDebits ?: 0) + acctgTransEntry.amount"/></then>
                        <else><set field="glAccountOrgTimePeriod.postedCredits" from="(glAccountOrgTimePeriod.postedCredits ?: 0) + acctgTransEntry.amount"/></else>
                    </if>
                    <set field="glAccountOrgTimePeriod.endingBalance" from="(glAccountOrgTimePeriod.endingBalance ?: 0) + postingAmount"/>

                    <entity-create value-field="glAccountOrgTimePeriod" or-update="true"/>
                </iterate>
            </iterate>

            <check-errors/>

            <!-- do the actual posting: set isPosted to Y and postedDate to now on AcctgTrans, use the EntityValue we already found -->
            <set field="acctgTrans.isPosted" value="Y"/>
            <set field="acctgTrans.postedDate" from="ec.user.nowTimestamp"/>
            <entity-update value-field="acctgTrans"/>
        </actions>
    </service>

    <service verb="post" noun="ReverseAcctgTrans">
        <description>Create a new transaction that is the reverse of the original (for each entry debits to credit and
            vice versa, transaction date set to now, etc).Clones the original transaction so new one will be associated
            with the same invoice, payment, etc.</description>
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="deleteIfNotPosted" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransId" required="true"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>

            <if condition="acctgTrans.isPosted != 'Y'"><if condition="deleteIfNotPosted">
                <then>
                    <service-call name="mantle.ledger.LedgerServices.delete#AcctgTrans" in-map="[acctgTransId:acctgTransId]"/>
                    <return/>
                </then>
                <else><return error="true" message="Not reversing transaction [${acctgTransId}], transaction is not posted"/></else>
            </if></if>

            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry" list="acctgTransEntryList">
                <econdition field-name="acctgTransId"/>
                <order-by field-name="acctgTransEntrySeqId"/>
            </entity-find>

            <set field="reverseAcctgTrans" from="acctgTrans.clone()"/>
            <set field="reverseAcctgTrans.acctgTransId" from="null"/>
            <entity-sequenced-id-primary value-field="reverseAcctgTrans"/>
            <set field="reverseAcctgTrans.reverseOfAcctgTransId" from="acctgTransId"/>
            <set field="reverseAcctgTrans.transactionDate" from="ec.user.nowTimestamp"/>
            <set field="reverseAcctgTrans.isPosted" value="N"/>
            <entity-create value-field="reverseAcctgTrans"/>

            <set field="reverseAcctgTransId" from="reverseAcctgTrans.acctgTransId"/>

            <set field="useErrorJournal" from="false"/>
            <iterate list="acctgTransEntryList" entry="acctgTransEntry">
                <set field="reverseAcctgTransEntry" from="acctgTransEntry.clone()"/>
                <set field="reverseAcctgTransEntry.acctgTransId" from="reverseAcctgTransId"/>
                <set field="reverseAcctgTransEntry.reconcileStatusId" value="AterNot"/>
                <set field="reverseAcctgTransEntry.debitCreditFlag"
                        from="reverseAcctgTransEntry.debitCreditFlag == 'C' ? 'D' : 'C'"/>
                <entity-create value-field="reverseAcctgTransEntry"/>

                <if condition="!reverseAcctgTransEntry.glAccountId"><set field="useErrorJournal" from="true"/></if>
            </iterate>

            <if condition="useErrorJournal">
                <!-- put in the error journal for the org -->
                <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                        in-map="[organizationPartyId:acctgTrans.organizationPartyId]"/>
                <if condition="partyAcctgPreference?.errorGlJournalId">
                    <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                            in-map="[acctgTransId:reverseAcctgTrans.acctgTransId,
                                glJournalId:partyAcctgPreference.errorGlJournalId]"/>
                </if>

                <else>
                    <!-- call the post service -->
                    <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans" in-map="[acctgTransId:reverseAcctgTransId]"/>
                </else>
            </if>

            <set field="acctgTrans.reversedByAcctgTransId" from="reverseAcctgTransId"/>
            <entity-update value-field="acctgTrans"/>

            <set field="acctgTransId" from="reverseAcctgTransId"/>
        </actions>
    </service>
    <service verb="move" noun="AcctgTransEntry">
        <description>Move a transaction entry from one account to another by posting a transaction reversing the original
            for just the given entry and redoing the original transaction in the other account. Clones the original
            transaction so new one will be associated with the same invoice, payment, etc.</description>
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTransEntrySeqId" required="true"/>
            <parameter name="glAccountId" required="true"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransId" required="true"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans"/>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTransEntry" value-field="acctgTransEntry"/>

            <if condition="acctgTrans.isPosted != 'Y'">
                <return error="true" message="Not moving transaction entry [${acctgTransId}:${acctgTransEntrySeqId}], transaction is not posted"/></if>
            <if condition="acctgTransEntry.glAccountId == glAccountId">
                <return message="Not moving transaction entry [${acctgTransId}:${acctgTransEntrySeqId}], entry is already posted to account ${glAccountId}"/></if>

            <set field="reverseAcctgTrans" from="acctgTrans.clone()"/>
            <set field="reverseAcctgTrans.acctgTransId" from="null"/>
            <entity-sequenced-id-primary value-field="reverseAcctgTrans"/>
            <set field="reverseAcctgTrans.transactionDate" from="ec.user.nowTimestamp"/>
            <set field="reverseAcctgTrans.isPosted" value="N"/>
            <entity-create value-field="reverseAcctgTrans"/>

            <set field="reverseAcctgTransId" from="reverseAcctgTrans.acctgTransId"/>

            <!-- reverse the original entry -->
            <set field="reverseAcctgTransEntry" from="acctgTransEntry.clone()"/>
            <set field="reverseAcctgTransEntry.acctgTransId" from="reverseAcctgTransId"/>
            <set field="reverseAcctgTransEntry.reconcileStatusId" value="AterNot"/>
            <set field="reverseAcctgTransEntry.debitCreditFlag"
                    from="reverseAcctgTransEntry.debitCreditFlag == 'C' ? 'D' : 'C'"/>
            <entity-create value-field="reverseAcctgTransEntry"/>

            <!-- create new entry in new account -->
            <set field="newAcctgTransEntry" from="acctgTransEntry.clone()"/>
            <set field="newAcctgTransEntry.acctgTransId" from="reverseAcctgTransId"/>
            <set field="newAcctgTransEntry.reconcileStatusId" value="AterNot"/>
            <set field="newAcctgTransEntry.glAccountId" from="glAccountId"/>
            <set field="newAcctgTransEntry.acctgTransEntrySeqId" from="null"/>
            <entity-sequenced-id-secondary value-field="newAcctgTransEntry"/>
            <entity-create value-field="newAcctgTransEntry"/>

            <!-- call the post service -->
            <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans" in-map="[acctgTransId:reverseAcctgTransId]"/>

            <set field="acctgTransId" from="reverseAcctgTransId"/>
        </actions>
    </service>

    <!-- =================================================== -->
    <!-- ========== Financial TimePeriod Services ========== -->
    <!-- =================================================== -->

    <service verb="check" noun="NextFiscalTimePeriods">
        <description>
            Ensure that at least current and next TimePeriods exist for FiscalMonth, FiscalQuarter (3 months), FiscalYear.
            If no time periods exist creates fiscal time periods based on calendar (ie fiscal year matches calendar year).
            If time periods do exist but not next time periods, adds next time period starting next day after current.
            This should be run once per month to ensure the next time period exists.
        </description>
        <in-parameters>
            <parameter name="organizationPartyId"/>
            <parameter name="basisDate" type="java.sql.Date" default="new java.sql.Date(ec.user.nowTimestamp.time)"/>
        </in-parameters>
        <actions>
            <script>basisCal = ec.user.getCalendarSafe(); basisCal.setTime(basisDate)</script>
            <entity-find-one entity-name="mantle.party.Organization" value-field="organization">
                <field-map field-name="partyId" from="organizationPartyId"/></entity-find-one>

            <!-- start with FiscalYear and go down so we have parentPeriodId -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentYearList"><date-filter valid-date="new Timestamp(basisDate.time)"/>
                <econdition field-name="partyId" from="organizationPartyId"/><econdition field-name="timePeriodTypeId" value="FiscalYear"/></entity-find>
            <if condition="!currentYearList">
                <then>
                    <!-- no current year... assume fiscal year is calendar year and create one automatically -->
                    <script>yearFromCal = basisCal.clone(); yearFromCal.set(Calendar.DAY_OF_YEAR, 1)</script>
                    <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                            in-map="[partyId:organizationPartyId, timePeriodTypeId:'FiscalYear',
                                fromDate:new java.sql.Date(yearFromCal.getTimeInMillis())]"/>
                    <set field="yearPeriodId" from="createTpOut.timePeriodId"/>
                </then>
                <else><set field="yearPeriodId" from="currentYearList.first.timePeriodId"/></else>
            </if>

            <!-- current quarter -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentQuarterList"><date-filter valid-date="new Timestamp(basisDate.time)"/>
                <econdition field-name="partyId" from="organizationPartyId"/><econdition field-name="timePeriodTypeId" value="FiscalQuarter"/></entity-find>
            <if condition="!currentQuarterList">
                <then>
                    <!-- no current quarter... assume fiscal year is calendar year with 4 3-month quarters and create one automatically -->
                    <script>quarterNumber = (int) (basisCal.get(Calendar.MONTH)/3)</script>
                    <script>quarterFromCal = basisCal.clone(); quarterFromCal.set(Calendar.MONTH, (quarterNumber * 3)); quarterFromCal.set(Calendar.DAY_OF_MONTH, 1)</script>
                    <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                            in-map="[partyId:organizationPartyId, timePeriodTypeId:'FiscalQuarter',
                                parentPeriodId:yearPeriodId, periodNum:(quarterNumber + 1),
                                fromDate:new java.sql.Date(quarterFromCal.getTimeInMillis())]"/>
                    <set field="quarterPeriodId" from="createTpOut.timePeriodId"/>
                </then>
                <else><set field="quarterPeriodId" from="currentQuarterList.first.timePeriodId"/></else>
            </if>

            <!-- current month -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentMonthList"><date-filter valid-date="new Timestamp(basisDate.time)"/>
                <econdition field-name="partyId" from="organizationPartyId"/><econdition field-name="timePeriodTypeId" value="FiscalMonth"/></entity-find>
            <if condition="!currentMonthList">
                <then>
                    <!-- no current quarter... assume fiscal year is calendar year with 4 3-month quarters and create one automatically -->
                    <script>monthNumber = basisCal.get(Calendar.MONTH)</script>
                    <script>monthFromCal = basisCal.clone(); monthFromCal.set(Calendar.DAY_OF_MONTH, 1)</script>
                    <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                            in-map="[partyId:organizationPartyId, timePeriodTypeId:'FiscalMonth',
                                parentPeriodId:quarterPeriodId, periodNum:(monthNumber + 1),
                                fromDate:new java.sql.Date(monthFromCal.getTimeInMillis())]"/>
                    <set field="monthPeriodId" from="createTpOut.timePeriodId"/>
                </then>


                <else><set field="monthPeriodId" from="currentMonthList.first.timePeriodId"/></else>
            </if>

            <!-- next year -->
            <!-- based on current year see if next exists and if not add one starting the day after and one year long -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="nextYearOut"
                    in-map="[timePeriodId:yearPeriodId]"/>
            <set field="nextYearPeriodId" from="nextYearOut.nextTimePeriodId"/>

            <!-- next quarter, may be in current or next year -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="nextQuarterOut"
                    in-map="[timePeriodId:quarterPeriodId]"/>
            <set field="nextQuarterPeriodId" from="nextQuarterOut.nextTimePeriodId"/>

            <!-- next month, may be in current or next quarter -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="nextMonthOut"
                    in-map="[timePeriodId:monthPeriodId]"/>
            <set field="nextMonthPeriodId" from="nextMonthOut.nextTimePeriodId"/>
        </actions>
    </service>
    <service verb="close" noun="FinancialTimePeriod">
        <in-parameters><parameter name="timePeriodId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod" for-update="true"/>
            <set field="fromTimestamp" from="ec.l10n.parseTimestamp(&quot;${timePeriod.fromDate} 00:00:00.000&quot;, '')"/>
            <set field="thruTimestamp" from="ec.l10n.parseTimestamp(&quot;${timePeriod.thruDate} 23:59:59.999&quot;, '')"/>

            <if condition="timePeriod.isClosed == 'Y'">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, already closed.</message>
            </if>
            <if condition="ec.user.nowTimestamp.before(timePeriod.thruDate)">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, period has not ended (ends on ${timePeriod.thruDate}).</message>
            </if>

            <!-- if any child periods make sure they are closed -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="childTimePeriodList">
                <econdition field-name="parentPeriodId" from="timePeriodId"/>
            </entity-find>
            <iterate list="childTimePeriodList" entry="childTimePeriod">
                <if condition="childTimePeriod.isClosed != 'Y'">
                    <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, child period ${ec.resource.expand('TimePeriodNameTemplate','',childTimePeriod)} not closed.</message>
                </if>
            </iterate>

            <!-- make sure there are no unposted transactions within the time period -->
            <entity-find-count entity-name="mantle.ledger.transaction.AcctgTrans" count-field="unpostedTransCount">
                <econdition field-name="isPosted" operator="not-equals" value="Y" or-null="true"/>
                <econdition field-name="transactionDate" operator="greater-equals" from="fromTimestamp"/>
                <econdition field-name="transactionDate" operator="less-equals" from="thruTimestamp"/>
            </entity-find-count>
            <if condition="unpostedTransCount &gt; 0">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, found ${unpostedTransCount} in period.</message>
            </if>

            <!-- check errors before continuing -->
            <check-errors/>

            <!-- first close the TimePeriod to avoid further postings -->
            <set field="timePeriod.isClosed" value="Y"/>
            <entity-update value-field="timePeriod"/>

            <!-- find the next TimePeriod (gets nextTimePeriodId, nextTimePeriod) -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="context"
                    in-map="[timePeriodId:timePeriodId]"/>

            <!-- recalculate postedDebits, postedCredits, endingBalance on GlAccountOrgTimePeriod records for this time period -->
            <service-call name="mantle.ledger.LedgerServices.recalculate#GlAccountOrgTimePeriodAmounts"
                    in-map="[timePeriodId:timePeriodId, nextTimePeriodId:nextTimePeriodId]"/>
        </actions>
    </service>
    <service verb="recalculate" noun="GlAccountOrgTimePeriodAmounts">
        <description>Recalculate postedDebits, postedCredits, endingBalance on GlAccountOrgTimePeriod records for a time period</description>
        <in-parameters>
            <parameter name="timePeriodId" required="true"/>
            <parameter name="nextTimePeriodId"><description>If specified updated record for next time period too (done on closing)</description></parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod" for-update="true"/>
            <set field="fromTimestamp" from="ec.l10n.parseTimestamp(&quot;${timePeriod.fromDate} 00:00:00.000&quot;, '')"/>
            <set field="thruTimestamp" from="ec.l10n.parseTimestamp(&quot;${timePeriod.thruDate} 23:59:59.999&quot;, '')"/>

            <entity-find entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" list="glAccountOrgTimePeriodList" for-update="true">
                <econdition field-name="organizationPartyId" from="timePeriod.partyId"/>
                <econdition field-name="timePeriodId"/>
            </entity-find>
            <iterate list="glAccountOrgTimePeriodList" entry="glAccountOrgTimePeriod">
                <set field="origGlAccountOrgTimePeriod" from="glAccountOrgTimePeriod.cloneValue()"/>

                <entity-find entity-name="mantle.ledger.transaction.AcctgTransAndEntrySummary" list="transSummaryList">
                    <!-- check above makes sure all transactions are posted, so don't filter by here -->
                    <econdition field-name="organizationPartyId" from="timePeriod.partyId"/>
                    <econdition field-name="transactionDate" operator="greater-equals" from="fromTimestamp"/>
                    <econdition field-name="transactionDate" operator="less-equals" from="thruTimestamp"/>
                    <econdition field-name="glAccountId" from="glAccountOrgTimePeriod.glAccountId"/>
                    <select-field field-name="debitCreditFlag"/><select-field field-name="amount"/>
                </entity-find>
                <!-- should have at most 2 results, debitCreditFlag=D, debitCreditFlag=C -->
                <set field="postedDebits" from="0"/><set field="postedCredits" from="0"/>
                <iterate list="transSummaryList" entry="transSummary"><if condition="transSummary.debitCreditFlag == 'D'">
                    <then><set field="postedDebits" from="transSummary.amount"/></then>
                    <else><set field="postedCredits" from="transSummary.amount"/></else>
                </if></iterate>
                <if condition="postedDebits != glAccountOrgTimePeriod.postedDebits">
                    <set field="glAccountOrgTimePeriod.postedDebits" from="postedDebits"/></if>
                <if condition="postedCredits != glAccountOrgTimePeriod.postedCredits">
                    <set field="glAccountOrgTimePeriod.postedCredits" from="postedCredits"/></if>

                <if condition="glAccountOrgTimePeriod.isModified()">
                    <!-- set the endingBalance based on beginningBalance, postedDebits, postedCredits -->
                    <entity-find-one entity-name="mantle.ledger.account.GlAccount" value-field="glAccount">
                        <field-map field-name="glAccountId" from="glAccountOrgTimePeriod.glAccountId"/></entity-find-one>
                    <service-call name="mantle.ledger.LedgerServices.find#RootGlAccountClassEnum" out-map="context"
                            in-map="[glAccountClassEnumId:glAccount.glAccountClassEnumId]"/>
                    <if condition="rootGlAccountClassEnumId == 'DEBIT'">
                        <then><set field="glAccountOrgTimePeriod.endingBalance" from="(glAccountOrgTimePeriod.beginningBalance?:0) +
                                (glAccountOrgTimePeriod.postedDebits?:0) - (glAccountOrgTimePeriod.postedCredits?:0)"/></then>
                        <else><set field="glAccountOrgTimePeriod.endingBalance" from="(glAccountOrgTimePeriod.beginningBalance?:0) -
                                (glAccountOrgTimePeriod.postedDebits?:0) + (glAccountOrgTimePeriod.postedCredits?:0)"/></else>
                    </if>

                    <log level="info" message="In close#FinancialTimePeriod found GlAccountOrgTimePeriod (organizationPartyId=${glAccountOrgTimePeriod.organizationPartyId}, timePeriodId=${glAccountOrgTimePeriod.timePeriodId}, glAccountId=${glAccountOrgTimePeriod.glAccountId}, root class ${rootGlAccountClassEnumId}) with wrong posted amounts; beginningBalance=${glAccountOrgTimePeriod.beginningBalance}, postedDebits was ${origGlAccountOrgTimePeriod.postedDebits} is ${glAccountOrgTimePeriod.postedDebits}, postedCredits was ${origGlAccountOrgTimePeriod.postedCredits} is ${glAccountOrgTimePeriod.postedCredits}, endingBalance was ${origGlAccountOrgTimePeriod.endingBalance} is ${glAccountOrgTimePeriod.endingBalance}"/>
                    <!-- update the record -->
                    <entity-update value-field="glAccountOrgTimePeriod"/>

                    <!-- TODO: also update postedBalance on GlAccount and GlAccountOrganization when we find a difference? -->
                </if>

                <!-- for each GlAccountOrgTimePeriod record for current period, set beginning balance for next period
                    (creating new records if they don't exist) -->
                <if condition="nextTimePeriodId">
                    <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod" for-update="true">
                        <field-map field-name="glAccountId" from="glAccountOrgTimePeriod.glAccountId"/>
                        <field-map field-name="organizationPartyId" from="timePeriod.partyId"/>
                        <field-map field-name="timePeriodId" from="nextTimePeriodId"/>
                    </entity-find-one>
                    <if condition="nextGlAccountOrgTimePeriod == null">
                        <entity-make-value entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod"
                            map="[glAccountId:glAccountOrgTimePeriod.glAccountId,  organizationPartyId:timePeriod.partyId,
                                timePeriodId:nextTimePeriodId, beginningBalance:0, postedDebits:0, postedCredits:0, endingBalance:0]"/>
                    </if>
                    <!-- add endingBalance to both just in case something has already been posted and added to next endingBalance -->
                    <set field="nextGlAccountOrgTimePeriod.endingBalance"
                            from="((nextGlAccountOrgTimePeriod.endingBalance ?: 0) - (nextGlAccountOrgTimePeriod.beginningBalance ?: 0)) +
                                glAccountOrgTimePeriod.endingBalance"/>
                    <!-- set next beginningBalance from current endingBalance; do after set next endingBalance because it uses next beginningBalance if there is a value -->
                    <set field="nextGlAccountOrgTimePeriod.beginningBalance" from="glAccountOrgTimePeriod.endingBalance"/>

                    <entity-create value-field="nextGlAccountOrgTimePeriod" or-update="true"/>
                </if>
            </iterate>
        </actions>
    </service>

    <!-- ========================================= -->
    <!-- ========== GL Journal Services ========== -->
    <!-- ========================================= -->

    <service verb="create" noun="GlJournal">
        <in-parameters>
            <auto-parameters include="nonpk"><exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
            <parameter name="glJournalName" required="true"/>
        </in-parameters>
        <out-parameters><parameter name="glJournalId"/></out-parameters>
        <actions>
            <set field="isPosted" value="N"/>
            <service-call name="create#mantle.ledger.transaction.GlJournal" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="GlJournal">
        <in-parameters>
            <parameter name="glJournalId" required="true"/>
            <auto-parameters include="nonpk"><exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
        </in-parameters>
        <actions>
            <service-call name="update#mantle.ledger.transaction.GlJournal" in-map="context"/>
        </actions>
    </service>

    <!-- is this even needed for anything?
    <service verb="calculate" noun="GlJournalTrialBalance">
        <in-parameters><parameter name="glJournalId" required="true"/></in-parameters>
        <out-parameters>
            <parameter name="debitTotal" type="BigDecimal"/>
            <parameter name="creditTotal" type="BigDecimal"/>
            <parameter name="debitCreditDifference" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <!- - implement this...? - ->
        </actions>
    </service>
    -->
    <service verb="post" noun="GlJournal">
        <description>Posts a GL Journal (GlJournal) by posting each transaction (AcctgTrans) in the journal.</description>
        <in-parameters>
            <parameter name="glJournalId" required="true"/>
            <parameter name="closeJournal" type="Boolean" default="false"/>
        </in-parameters>
        <actions>
            <!-- lock the Journal first -->
            <entity-find-one entity-name="mantle.ledger.transaction.GlJournal" value-field="glJournal" for-update="true"/>

            <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="acctgTransList">
                <econdition field-name="glJournalId"/><order-by field-name="acctgTransId"/>
            </entity-find>
            <set field="txPostCount" from="0"/>
            <iterate list="acctgTransList" entry="acctgTrans">
                <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans"
                        in-map="[acctgTransId:acctgTrans.acctgTransId]"/>
                <if condition="ec.message.hasError()">
                    <return error="true"/>
                    <else><set field="txPostCount" from="txPostCount + 1"/></else>
                </if>
            </iterate>
            <message>Posted ${txPostCount} transactions</message>

            <if condition="closeJournal">
                <set field="glJournal.isPosted" value="Y"/>
                <set field="glJournal.postedDate" from="ec.user.nowTimestamp"/>
                <entity-update value-field="glJournal"/>
            </if>
        </actions>
    </service>
</services>
